used';
	print				  '6468: test unused';
	print				  '6469: test unused';

	/*
	 * test isrand
	 */
	vrfy(isrand(loc) == 0,		  '6470: isrand(loc) == 0');
	vrfy(isrand(a) == 0,		  '6471: isrand(a) == 0');
	vrfy(isrand(ofd) == 0,		  '6472: isrand(ofd) == 0');
	vrfy(isrand(cfd) == 0,		  '6473: isrand(cfd) == 0');
	vrfy(isrand(blk) == 0,		  '6474: isrand(blk) == 0');
	vrfy(isrand(nblk) == 0,		  '6475: isrand(nblk) == 0');
	vrfy(isrand(cfg) == 0,		  '6476: isrand(cfg) == 0');
	vrfy(isrand(serr) == 0,		  '6477: isrand(serr) == 0');
	vrfy(isrand(nerr) == 0,		  '6478: isrand(nerr) == 0');
	vrfy(isrand(odd) == 0,		  '6479: isrand(odd) == 0');
	vrfy(isrand(even) == 0,		  '6480: isrand(even) == 0');
	vrfy(isrand(hash) == 0,		  '6481: isrand(hash) == 0');
	vrfy(isrand(id) == 0,		  '6482: isrand(id) == 0');
	vrfy(isrand(list) == 0,		  '6483: isrand(list) == 0');
	vrfy(isrand(matrix) == 0,	  '6484: isrand(matrix) == 0');
	vrfy(isrand(nul) == 0,		  '6485: isrand(nul) == 0');
	vrfy(isrand(object) == 0,	  '6486: isrand(object) == 0');
	vrfy(isrand(rand) == 1,		  '6487: isrand(rand) == 1');
	vrfy(isrand(random) == 0,	  '6488: isrand(random) == 0');
	vrfy(isrand(real) == 0,		  '6489: isrand(real) == 0');
	vrfy(isrand(prime) == 0,	  '6490: isrand(prime) == 0');
	vrfy(isrand(square) == 0,	  '6491: isrand(square) == 0');
	vrfy(isrand(string) == 0,	  '6492: isrand(string) == 0');
	vrfy(isrand(com) == 0,		  '6493: isrand(com) == 0');
	print				  '6494: test unused';
	print				  '6495: test unused';
	print				  '6495: test unused';
	print				  '6496: test unused';
	print				  '6497: test unused';
	print				  '6498: test unused';
	print				  '6499: test unused';

	/*
	 * test israndom
	 */
	vrfy(israndom(loc) == 0,	  '6500: israndom(loc) == 0');
	vrfy(israndom(a) == 0,		  '6501: israndom(a) == 0');
	vrfy(israndom(ofd) == 0,	  '6502: israndom(ofd) == 0');
	vrfy(israndom(cfd) == 0,	  '6503: israndom(cfd) == 0');
	vrfy(israndom(blk) == 0,	  '6504: israndom(blk) == 0');
	vrfy(israndom(nblk) == 0,	  '6505: israndom(nblk) == 0');
	vrfy(israndom(cfg) == 0,	  '6506: israndom(cfg) == 0');
	vrfy(israndom(serr) == 0,	  '6507: israndom(serr) == 0');
	vrfy(israndom(nerr) == 0,	  '6508: israndom(nerr) == 0');
	vrfy(israndom(odd) == 0,	  '6509: israndom(odd) == 0');
	vrfy(israndom(even) == 0,	  '6510: israndom(even) == 0');
	vrfy(israndom(hash) == 0,	  '6511: israndom(hash) == 0');
	vrfy(israndom(id) == 0,		  '6512: israndom(id) == 0');
	vrfy(israndom(list) == 0,	  '6513: israndom(list) == 0');
	vrfy(israndom(matrix) == 0,	  '6514: israndom(matrix) == 0');
	vrfy(israndom(nul) == 0,	  '6515: israndom(nul) == 0');
	vrfy(israndom(object) == 0,	  '6516: israndom(object) == 0');
	vrfy(israndom(rand) == 0,	  '6517: israndom(rand) == 0');
	vrfy(israndom(random) == 1,	  '6518: israndom(random) == 1');
	vrfy(israndom(real) == 0,	  '6519: israndom(real) == 0');
	vrfy(israndom(prime) == 0,	  '6520: israndom(prime) == 0');
	vrfy(israndom(square) == 0,	  '6521: israndom(square) == 0');
	vrfy(israndom(string) == 0,	  '6522: israndom(string) == 0');
	vrfy(israndom(com) == 0,	  '6523: israndom(com) == 0');
	print				  '6524: test unused';
	print				  '6525: test unused';
	print				  '6526: test unused';
	print				  '6527: test unused';
	print				  '6528: test unused';
	print				  '6529: test unused';

	/*
	 * test isreal
	 */
	vrfy(isreal(loc) == 1,		  '6530: isreal(loc) == 1');
	vrfy(isreal(a) == 0,		  '6531: isreal(a) == 0');
	vrfy(isreal(ofd) == 0,		  '6532: isreal(ofd) == 0');
	vrfy(isreal(cfd) == 0,		  '6533: isreal(cfd) == 0');
	vrfy(isreal(blk) == 0,		  '6534: isreal(blk) == 0');
	vrfy(isreal(nblk) == 0,		  '6535: isreal(nblk) == 0');
	vrfy(isreal(cfg) == 0,		  '6536: isreal(cfg) == 0');
	vrfy(isreal(serr) == 0,		  '6537: isreal(serr) == 0');
	vrfy(isreal(nerr) == 0,		  '6538: isreal(nerr) == 0');
	vrfy(isreal(odd) == 1,		  '6539: isreal(odd) == 1');
	vrfy(isreal(even) == 1,		  '6540: isreal(even) == 1');
	vrfy(isreal(hash) == 0,		  '6541: isreal(hash) == 0');
	vrfy(isreal(id) == 0,		  '6542: isreal(id) == 0');
	vrfy(isreal(list) == 0,		  '6543: isreal(list) == 0');
	vrfy(isreal(matrix) == 0,	  '6544: isreal(matrix) == 0');
	vrfy(isreal(nul) == 0,		  '6545: isreal(nul) == 0');
	vrfy(isreal(object) == 0,	  '6546: isreal(object) == 0');
	vrfy(isreal(rand) == 0,		  '6547: isreal(rand) == 0');
	vrfy(isreal(random) == 0,	  '6548: isreal(random) == 0');
	vrfy(isreal(real) == 1,		  '6549: isreal(real) == 1');
	vrfy(isreal(prime) == 1,	  '6550: isreal(prime) == 1');
	vrfy(isreal(square) == 1,	  '6551: isreal(square) == 1');
	vrfy(isreal(string) == 0,	  '6552: isreal(string) == 0');
	vrfy(isreal(com) == 0,		  '6553: isreal(com) == 0');
	print				  '6554: test unused';
	print				  '6555: test unused';
	print				  '6555: test unused';
	print				  '6556: test unused';
	print				  '6557: test unused';
	print				  '6558: test unused';
	print				  '6559: test unused';

	/*
	 * test isrel
	 */
	vrfy(isrel(odd,even) == 0,	  '6560: isrel(odd,even) == 0');
	vrfy(isrel(even,odd) == 0,	  '6561: isrel(even,odd) == 0');
	vrfy(isrel(odd,odd) == 0,	  '6562: isrel(odd,odd) == 0');
	vrfy(isrel(even,prime) == 1,	  '6563: isrel(even,prime) == 1');
	vrfy(isrel(square,prime) == 0,	  '6564: isrel(square,prime) == 0');
	vrfy(isrel(prime,square) == 0,	  '6565: isrel(prime,square) == 0');
	vrfy(isrel(even,square) == 1,	  '6566: isrel(even,square) == 1');
	vrfy(isrel(prime,even) == 1,	  '6567: isrel(prime,even) == 1');
	print				  '6568: test unused';
	print				  '6569: test unused';

	/*
	 * test bit (this was isset and thus was included here, however
	 *	     we leave it here for now rather than renumber
	 *	     the tests below)
	 */
	vrfy(bit(odd,0) == 1,		  '6570: bit(odd,0) == 1');
	vrfy(bit(odd,1) == 0,		  '6571: bit(odd,1) == 0');
	vrfy(bit(odd,2) == 0,		  '6572: bit(odd,2) == 0');
	vrfy(bit(odd,3) == 1,		  '6573: bit(odd,3) == 1');
	vrfy(bit(real,4) == 1,		  '6574: bit(real,4) == 1');
	vrfy(bit(real,5) == 0,		  '6575: bit(real,5) == 0');
	vrfy(bit(real,6) == 1,		  '6576: bit(real,6) == 1');
	vrfy(bit(real,7) == 0,		  '6577: bit(real,7) == 0');
	print				  '6578: test unused';
	print				  '6579: test unused';

	/*
	 * test issimple
	 */
	vrfy(issimple(loc) == 1,	  '6580: issimple(loc) == 1');
	vrfy(issimple(a) == 0,		  '6581: issimple(a) == 0');
	vrfy(issimple(ofd) == 0,	  '6582: issimple(ofd) == 0');
	vrfy(issimple(cfd) == 0,	  '6583: issimple(cfd) == 0');
	vrfy(issimple(blk) == 0,	  '6584: issimple(blk) == 0');
	vrfy(issimple(nblk) == 0,	  '6585: issimple(nblk) == 0');
	vrfy(issimple(cfg) == 0,	  '6586: issimple(cfg) == 0');
	vrfy(issimple(serr) == 0,	  '6587: issimple(serr) == 0');
	vrfy(issimple(nerr) == 0,	  '6588: issimple(nerr) == 0');
	vrfy(issimple(odd) == 1,	  '6589: issimple(odd) == 1');
	vrfy(issimple(even) == 1,	  '6590: issimple(even) == 1');
	vrfy(issimple(hash) == 0,	  '6591: issimple(hash) == 0');
	vrfy(issimple(id) == 0,		  '6592: issimple(id) == 0');
	vrfy(issimple(list) == 0,	  '6593: issimple(list) == 0');
	vrfy(issimple(matrix) == 0,	  '6594: issimple(matrix) == 0');
	vrfy(issimple(nul) == 1,	  '6595: issimple(nul) == 1');
	vrfy(issimple(object) == 0,	  '6596: issimple(object) == 0');
	vrfy(issimple(rand) == 0,	  '6597: issimple(rand) == 0');
	vrfy(issimple(random) == 0,	  '6598: issimple(random) == 0');
	vrfy(issimple(real) == 1,	  '6599: issimple(real) == 1');
	vrfy(issimple(prime) == 1,	  '6600: issimple(prime) == 1');
	vrfy(issimple(square) == 1,	  '6601: issimple(square) == 1');
	vrfy(issimple(string) == 1,	  '6602: issimple(string) == 1');
	vrfy(issimple(com) == 1,	  '6603: issimple(com) == 1');
	print				  '6604: test unused';
	print				  '6605: test unused';
	print				  '6606: test unused';
	print				  '6607: test unused';
	print				  '6608: test unused';
	print				  '6609: test unused';

	/*
	 * test issq
	 */
	vrfy(issq(loc) == 1,		  '6610: issq(loc) == 1');
	vrfy(issq(odd) == 0,		  '6611: issq(odd) == 0');
	vrfy(issq(even) == 0,		  '6612: issq(even) == 0');
	vrfy(issq(prime) == 0,		  '6613: issq(prime) == 0');
	vrfy(issq(square) == 1,		  '6614: issq(square) == 1');
	print				  '6615: test unused';
	print				  '6616: test unused';
	print				  '6618: test unused';
	print				  '6618: test unused';
	print				  '6619: test unused';

	/*
	 * test isstr
	 */
	vrfy(isstr(loc) == 0,		  '6620: isstr(loc) == 0');
	vrfy(isstr(a) == 0,		  '6621: isstr(a) == 0');
	vrfy(isstr(ofd) == 0,		  '6622: isstr(ofd) == 0');
	vrfy(isstr(cfd) == 0,		  '6623: isstr(cfd) == 0');
	vrfy(isstr(blk) == 0,		  '6624: isstr(blk) == 0');
	vrfy(isstr(nblk) == 0,		  '6625: isstr(nblk) == 0');
	vrfy(isstr(cfg) == 0,		  '6626: isstr(cfg) == 0');
	vrfy(isstr(serr) == 0,		  '6627: isstr(serr) == 0');
	vrfy(isstr(nerr) == 0,		  '6628: isstr(nerr) == 0');
	vrfy(isstr(odd) == 0,		  '6629: isstr(odd) == 0');
	vrfy(isstr(even) == 0,		  '6630: isstr(even) == 0');
	vrfy(isstr(hash) == 0,		  '6631: isstr(hash) == 0');
	vrfy(isstr(id) == 0,		  '6632: isstr(id) == 0');
	vrfy(isstr(list) == 0,		  '6633: isstr(list) == 0');
	vrfy(isstr(matrix) == 0,	  '6634: isstr(matrix) == 0');
	vrfy(isstr(nul) == 0,		  '6635: isstr(nul) == 0');
	vrfy(isstr(object) == 0,	  '6636: isstr(object) == 0');
	vrfy(isstr(rand) == 0,		  '6637: isstr(rand) == 0');
	vrfy(isstr(random) == 0,	  '6638: isstr(random) == 0');
	vrfy(isstr(real) == 0,		  '6639: isstr(real) == 0');
	vrfy(isstr(prime) == 0,		  '6640: isstr(prime) == 0');
	vrfy(isstr(square) == 0,	  '6641: isstr(square) == 0');
	vrfy(isstr(string) == 1,	  '6642: isstr(string) == 1');
	vrfy(isstr(com) == 0,		  '6643: isstr(com) == 0');
	print				  '6644: test unused';
	print				  '6645: test unused';
	print				  '6645: test unused';
	print				  '6646: test unused';
	print				  '6647: test unused';
	print				  '6648: test unused';
	print				  '6649: test unused';

	/*
	 * test istype
	 */
	vrfy(istype(odd,even) == 1,	  '6650: istype(odd,even) == 1');
	vrfy(istype(even,odd) == 1,	  '6651: istype(even,odd) == 1');
	vrfy(istype(odd,odd) == 1,	  '6652: istype(odd,odd) == 1');
	vrfy(istype(even,prime) == 1,	  '6653: istype(even,prime) == 1');
	vrfy(istype(square,prime) == 1,	  '6654: istype(square,prime) == 1');
	vrfy(istype(prime,square) == 1,	  '6655: istype(prime,square) == 1');
	vrfy(istype(even,square) == 1,	  '6656: istype(even,square) == 1');
	vrfy(istype(prime,even) == 1,	  '6657: istype(prime,even) == 1');
	vrfy(istype(prime,com) == 0,	  '6658: istype(prime,com) == 0');
	vrfy(istype(matrix,com) == 0,	  '6659: istype(matrix,com) == 0');

	vrfy(istype(matrix,list) == 0,	  '6660: istype(matrix,list) == 0');
	vrfy(istype(matrix,odd) == 0,	  '6661: istype(matrix,odd) == 0');
	vrfy(istype(a,odd) == 0,	  '6662: istype(a,odd) == 0');

	/*
	 * perform more extensive issq() testing
	 */
	ok = 1;
	for (i=0; i < 256; ++i) {
		/* rndval will be a square - even powers>0 of x>1 */
		rndexp = random(1, 16) * 2;
		rndint = random(2, 4294967296);
		if (issq(rndint)) {
			++rndint;
		}
		rndval = rndint ^ rndexp;
		if (issq(rndval) == 0) {
			prob(strprintf("issq(%d^%d) returned 0",
					rndint, rndexp));
			ok = 0;
		}
	}
	if (ok) {
		print	  '6663: issq() on 256 squares';
	} else {
		print	  '****: failure(s): 6663: faiissq() on 256 squares';
	}
	for (i=0; i < 256; ++i) {
		/* rndval will not be a square - 1 + even powers>0 of x>1 */
		rndexp = random(1, 16) * 2;
		rndint = random(2, 4294967296);
		rndval = rndint ^ rndexp;
		if (issq(rndval+1) != 0) {
			prob(strprintf("issq(%d^%d)+1 returned non-zero",
					rndint, rndexp));
			ok = 0;
		}
	}
	if (ok) {
		print	  '6664: issq() on 256 squares+1';
	} else {
		print	  '****: failure(s): 6664: issq() on 256 squares+1';
	}
	print				  '6664: issq() on 256 squares+1';
	for (i=0; i < 256; ++i) {
		/* rndval will not be a square - odd powers>0 of x>1 */
		rndexp = (random(1, 16) * 2) + 1;
		rndint = random(2, 4294967296);
		if (issq(rndint)) {
			++rndint;
		}
		rndval = rndint ^ rndexp;
		if (issq(rndval) != 0) {
			prob(strprintf("issq(%d^%d) returned non-zero",
					rndint, rndexp));
			ok = 0;
		}
	}
	if (ok) {
		print	  '6665: issq() on 256 non-squares';
	} else {
		print	  '****: failure(s): 6665: issq() on 256 non-squares';
	}

	/*
	 * cleanup
	 */
	blkfree("blk5900");
	print				  '6666: blkfree("blk5900")';
	fclose(ofd);
	print				  '6667: fclose(ofd)';

	print '6668: Ending test_is';
}
print '168: test_is()';


/*
 * test_blk - test block of octets
 */
define test_blk()
{
	local A, B, C, A1, A2, B1;

	print '6700: Beginning test_blk';

	A = blk(20);
	print				  '6701: A = blk(20);';
	vrfy(size(A) == 20,		  '6702: size(A) == 20');
	vrfy(sizeof(A) == 256,		  '6703: sizeof(A) == 256');
	B = A;
	print				  '6704: B = A;';
	vrfy(size(B) == 20,		  '6705: size(B) == 20');
	vrfy(A == B,			  '6706: A == B');

	A[5] = 21;
	print				  '6707: A[5] = 21;';
	vrfy(A[5] == 21,		  '6708: A[5] == 21');

	A[6] = 'abc';
	print				  '6709: A[6] = "abc";';
	vrfy(A[6] == ord('a'),		  '6710: A[6] == ord("a")');

	A[7] = 260;
	print				  '6711: A[7] = 260;';
	vrfy(A[7] == 4,			  '6712: A[7] == 4');

	A[8] = 3+4i;
	print				  '6713: A[8] = 3+4i;';
	vrfy(A[8] == 3,			  '6714: A[8] == 3');

	vrfy(A != B,			  '6715: A != B');

	/* Equality of blocks of same data-length is unaffected by maxsizes */

	C = blk(A, ,128);
	print				  '6716: C = blk(A, ,128);';
	vrfy(size(C) == size(A),	  '6717: size(C) == size(A)');
	vrfy(sizeof(C) == 128,		  '6718: sizeof(C) == 128');
	vrfy(C == A,			  '6719: C == A');

	/* Blocks of different lengths test as unequal */

	C = blk(A,30);
	print				  '6720: C = blk(A,30);';
	vrfy(size(C) == 30,		  '6721: size(C) == 30');
	vrfy(C != A,			  '6722: C != A;');

	/* Reducing length to that of original data restores equality */

	C = blk(C,20);
	print				  '6723: C = blk(C,20);';
	vrfy(C == A,			  '6724: C == A');

	/* Reading block beyond data length extends length */

	A[29] = 7;
	print				  '6725: A[29] = 7;';
	vrfy(A[29] == 7,		  '6726: A[29] == 7');
	vrfy(size(A) == 30,		  '6727: size(A) == 30');

	/* Reducing length clears memory beyond new length */

	A = blk(A, 20);
	print				  '6728: A = blk(A, 20);';
	vrfy(A[29] == 0,		  '6729: A[29] == 0');

	/* Reducing length to zero and initializing a few early values */

	A = blk(A,0) = {1,,3,,5};
	print				  '6730: A = blk(A,0) = {1,,3,5};';

	vrfy(A[4] == 5,			  '6731: A[4] == 5');
	vrfy(size(A) == 5,		  '6732: size(A) == 5');

	/* Assignment of copy with initialization */

	B = A;
	print				  '6733: B = A;';
	C=blk(A)={,,,,,,,,,,0xbb};
	print				  '6734: C=blk(A)={,,,,,,,,,,0xbb};';

	/* A has not been changed */

	vrfy(A == B,			  '6735: A == B');
	vrfy(C[10] == 0xbb,		  '6736: C[10] == 0xbb');

	/* Testing named blocks */

	A1 = blk("blk6700");
	print				  '6737: A1 = blk("blk6700");';
	A2 = blk("blk6700");
	print				  '6738: A2 = blk("blk6700");';
	vrfy(A1 == A2,			  '6739: A1 == A2');
	vrfy(size(A1) == 0,		  '6740: size(A1) == 0');
	vrfy(sizeof(A1) == 256,		  '6741: sizeof(A1) == 256');
	print '6742: test disabled: test(A1) == 0';
	print '6743: test disabled: str(A1) == "blk6700"';
	vrfy(blocks() == 1,		  '6744: blocks() == 1');
	vrfy(blocks(1) == A1,		  '6745: blocks(1) == A1');

	/* A second named block */

	B1 = blk("+++6700", 15, 10) = {1,2,3,4,5};
	print				  '6746: B1 = blk("+++6700", 15 , 10) = {1,2,3,4,5};';
	vrfy(size(B1) == 15,		  '6747: size(B1) == 15');
	vrfy(sizeof(B1) == 20,		  '6748: sizeof(B1) == 20');
	vrfy(test(B1) == 1,		  '6749: test(B1) == 1');
	print '6750: test disabled: str(B1) == "+++6700"';
	vrfy(blocks() == 2,		  '6751: blocks() == 2');
	vrfy(blocks(2) == B1,		  '6752: blocks(2) == B1');
	vrfy(B1 != A1,			  '6753: B1 != A1');

	/* Referencing octets beyond datalen increases datalen */

	A1[15] = 29;
	print				  '6754: A1[15] = 29;';
	vrfy(A1[15] == 29,		  '6755: A1[15] == 29');
	vrfy(A2[15] == 29,		  '6756: A2[15] == 29');
	vrfy(size(A1) == 16,		  '6757: size(A1) == 16');
	vrfy(test(A1) == 1,		  '6758: test(A1) == 1');
	A1[99] = 11;
	print				  '6759: A1[99] = 11;';
	vrfy(size(A1) == 100,		  '6760: size(A1) == 100');
	vrfy(A1[99] == 11,		  '6761: A1[99] == 11');

	/* increasing chunksize */

	null(blk(A1, , 1000));
	print				  '6762: null(blk(A1, , 1000));';
	vrfy(size(A1) == 100,		  '6763: size(A1) == 100');
	vrfy(sizeof(A1) == 1000,	  '6764: sizeof(A1) == 1000');
	vrfy(A1[99] == 11,		  '6765: A1[99] == 11');

	/* reducing data-length */

	A1 = blk(A1, 10);
	print				  '6766: A1 = blk(A1, 10);';
	vrfy(size(A1) == 10,		  '6767: size(A1) == 10');

	/* all octets now zero */

	vrfy(test(A1) == 0,		  '6768: test(A1) == 0');
	vrfy(A1[99] == 0,		  '6769: A1[99] == 0');

	/* freeing memory */

	blkfree(A1);
	print				  '6770: blkfree(A1);';

	/* freeing named block memory reduces number of unfreed blocks */

	vrfy(blocks() == 1,		  '6771: blocks() == 1');

	/* 'removed' block still exists but has zero size and maxsize */

	vrfy(blocks(1) == A1,		  '6772: blocks(1) == A1');
	vrfy(size(A1) == 0,		  '6773: size(A1) == 0');
	vrfy(sizeof(A1) == 0,		  '6774: sizeof(A1) == 0');
	vrfy(test(A1) == 0,		  '6775: test(A1) == 0');
	print '6776: test disabled: str(A1) == "blk6700"';

	/* Equality of named blocks not affected by freeing of memory */

	vrfy(A1 == A2,			  '6777: A1 == A2');

	/* Executing blk('blk6700') reallocates memory for A1 */

	null(blk('blk6700'));
	print				  '6778: null(blk("blk6700"));';
	vrfy(size(A1) == 0,		  '6779: size(A1) == 0');
	vrfy(sizeof(A1) == 1000,	  '6780: sizeof(A1) == 1000');

	/* A2 still refers to same block as A1 */

	A1[100] = 0xff;
	print				  '6781: A1[100] = 0xff;';
	vrfy(A2[100] == 0xff,		  '6782: A2[100] == 0xff');

	/* A possibly confusing initialization and assignment */

	mat A1[2] = {A1, B1};
	print				  '6783: mat A1[2] = {A1, B1};';
	vrfy(A1[0] == A2,		  '6784: A1[0] == A2');
	vrfy(A1[1] == B1,		  '6785: A1[1] == B1');
	vrfy(A1[0][100] == 0xff,	  '6786: A1[0][100] == 0xff');

	print '6800: reserved for future expansion of test_blk';

	print '6899: Ending test_blk';
}
print '169: parsed test_blk()';


/*
 * test_blkcpy - test the new copy builtin function
 */
define test_blkcpy()
{
	local A, B, C, A1, A2, B1, fs, S, M1, M2, L1, L2, x;

	print	'6800: Beginning test_blkcpy';

	A = blk() = {1,2,3,4,5};
	print				  '6801: A = blk() = {1,2,3,4,5};';
	B = blk();
	print				  '6802: B = blk();';
	blkcpy(B, A);
	print				  '6803: blkcpy(B, A);';
	vrfy(A == B,			  '6804: A == B');
	blkcpy(B, A, ,10);
	print				  '6805: blkcpy(B, A, ,10)';
	vrfy(size(B) == 15,		  '6806: size(B) == 15');
	blkcpy(B, A, , 15, 3);
	print				  '6807: blkcpy(A, 3, B, 15);';
	vrfy(size(B) == 17,		  '6808: size(B) == 17');
	vrfy(B[16] == 5,		  '6809: B[16] == 5');

	/* create named block A1 and blkcpy A into B[0]... and B[100]... */

	x = rm("-f", "blk6800");
	print				  '6810: x = rm("-f", "blk6800")';
	A1 = blk("blk6800");
	print				  '6811: A1 = blk("blk6800");';
	vrfy(size(A1) == 0,		  '6812: size(A1) == 0');
	blkcpy(A1, A);
	print				  '6813: blkcpy(A1, A);';
	vrfy(size(A1) == 5,		  '6814: size(A1) == 5');
	blkcpy(A1, A, ,100);
	print				  '6815: blkcpy(A1, A, ,100);';
	vrfy(size(A1) == 105,		  '6816: size(A1) == 105');

	/* create named block B1 and blkcpy first 5 octets of A1 to B[100]... */

	B1 = blk("beta");
	print				  '6817: B1 = blk("beta")';
	vrfy(size(B1) == 0,		  '6818: size(B1) == 0');
	blkcpy(B1, A1, 5, 100, 0);
	print				  '6819: blkcpy(B1, A1, 5, 100, 0)';
	vrfy(size(B1) == 105,		  '6820: size(B1) == 105');

	/* blkcpy the last 5 octets of B1 to a new block C */

	blkcpy(C = blk(), B1,5,,100);
	print				  '6821: blkcpy(C = blk(), B1,5,,100);';
	vrfy(C == A,			  '6822: C == A');

	/* blkcpy to and from a file */

	fs = fopen("junk6800", "w+");
	print				  '6823: fs = fopen("junk6800", "w+");';
	blkcpy(fs, A);
	print				  '6824: blkcpy(fs, A);';
	vrfy(size(fs) == 5,		  '6825: size(f) == 5');
	blkcpy(B = blk(), fs);
	print				  '6826: blkcpy(B = blk(), fs);';
	vrfy(B == A,			  '6827: B == A');
	blkcpy(fs, A, ,100);
	print				  '6828: blkcpy(fs, A, ,100);';
	vrfy(size(fs) == 105,		  '6829: size(f) == 105');
	blkcpy(C = blk(), fs,2,,100);
	print				  '6830: blkcpy(C = blk(), fs,2,,100)';
	vrfy(C == (blk() = {1,2}),	  '6831: C == (blk() = {1,2}');

	/* blkcpy string to a block */

	A = blk();
	print				  '6832: A = blk();';

	/* Note that "blk6800" is not here considered to name a block */

	blkcpy(A, "blk6800 ");
	print				  '6833: blkcpy(A, "blk6800");';
	vrfy(size(A) == 9,		  '6834: size(A) == 9');
	blkcpy(A, "beta", , 7);
	print				  '6835: blkcpy(A, "beta", , 7);';
	vrfy(size(A) == 12,		  '6836: size(A) == 12');

	/* read strings from A */

	S = strprintf("%s", A[0]);
	print				  '6837: S = strprintf("%s", A[0]);';
	vrfy(S == "blk6800beta",	  '6838: S == "blk6800beta"');
	S = strprintf("%s", A[8]);
	print				  '6839: S = strprintf("%s", A[8]);';
	vrfy(S == "eta",		  '6840: S == "eta"');

	mat M1[2,2] = {1,2,3,4};
	print				  '6841: mat M1[2,2] = {1,2,3,4};';
	mat M2[4];
	print				  '6842: mat M2[4];';
	blkcpy(M2, M1);
	print				  '6843: blkcpy(M2, M1)';
	vrfy(M2 == (mat[4]={1,2,3,4}),	  '6844: M2 == (mat[4]={1,2,3,4}');
	blkcpy(M2, M2, 2, 2, 0);
	print				  '6845: blkcpy(M2, M2, 2, 2, 0);';
	vrfy(M2 == (mat[4]={1,2,1,2}),	  '6846: M2 == (mat[4]={1,2,1,2}');

	/* blkcpy between blocks and matrices */

	B = blk();
	print				  '6847: B = blk()';
	blkcpy(B, M1);
	print				  '6848: blkcpy(B, M1)';
	vrfy(B == (blk() = {1,2,3,4}),	  '6849: B == (blk() = {1,2,3,4}');
	blkcpy(M2, B, 2, ,2);
	print				  '6850: blkcpy(B,2,2,M2);';
	vrfy(M2 == (mat[4]={3,4,1,2}),	  '6851: M2 == (mat[4]={3,4,1,2})');

	/* blkcpy between matrices and lists */

	L1 = makelist(4);
	print				  '6852: L1 = makelist(4);';
	blkcpy(L1, M2);
	print				  '6853: blkcpy(L1, M2);';

	blkcpy(M2, L1, 2, ,2);
	print				  '6854: blkcpy(M2, L1, 2, ,2);';
	vrfy(M2 == (mat[4]={1,2,1,2}),	  '6855: M2 == (mat[4]={1,2,1,2}');

	/* blkcpy lists to lists */

	L2 = makelist(4);
	print				  '6856: L2 = makelist(4);';
	blkcpy(L2, L1);
	print				  '6857: blkcpy(L2, L1);';
	vrfy(L1 == L2,			  '6858: L1 == L2');
	blkcpy(L2, L1, 2, 2, 0);
	print				  '6859: blkcpy(L2, L1, 2, 2, 0)';
	vrfy(L2 == list(3,4,3,4),	  '6860: L2 == list(3,4,3,4)');

	/* blkcpy between structures and substructures */

	M2[0] = L2;
	print				  '6861: M2[0] = L2;';
	blkcpy(M2, M2[0]);
	print				  '6862: blkcpy(M2, M2[0]);';
	vrfy(M2 == (mat[4]={3,4,3,4}),	  '6863: M2 == (mat[4]={3,4,3,4})');
	M2[2] = list(1,2,3,4);
	print				  '6864: M2[2] = list(1,2,3,4);';
	blkcpy(M2[2], M2);
	print				  '6865: blkcpy(M2[2], M2);';
	vrfy(M2[2][[2]][[2]] == 3,	  '6866: M2[2][[2]][[2]] == 3');

	/* cleanup */
	fclose(fs);
	print				  '6867: fclose(fs)';
	x = rm("junk6800");
	print				  '6868: x = rm("junk6800")';

	print '6868: Ending test_blkcpy';
}
print '170: parsed test_blkcpy()';


/*
 * test_name - test the name builtin
 */
define test_name()
{
	local f, A, x;

	print '6900: Beginning test_name';

	x = rm("-f", "junk6900");
	print				  '6901: x = rm("-f", "junk6900")';
	f = fopen("junk6900", "w");
	print				  '6902: f = fopen("junk6900", "w")';
	vrfy(name(f) == "junk6900",	  '6903: name(f) == "junk6900"');

	/* file stream loses name when file is closed */

	fclose(f);
	print				  '6904: fclose(f)';
	vrfy(name(f) == null(),		  '6905: name(f) == null()');
	A = blk("blk6900");
	print				  '6906: A = blk("blk6900")';
	vrfy(name(A) == "blk6900",	  '6907: name(A) == "blk6900"');

	/* name of block is not lost when its data memory is freed */

	blkfree("blk6900");
	print				  '6908: blkfree("blk6900");';
	vrfy(name(A) == "blk6900",	  '6909: name(A) == "blk6900"');

	/* values other than named blocks and files have no name */

	vrfy(name(27) == null(),	  '6910: name(27) == null()');

	/* cleanup */

	x = rm("junk6900");
	print				  '6911: x = rm("junk6900")';

	print '6912: Ending test_name';
}
print '171: parsed test_name()';


/*
 * test_blkprintf - test blk printf
 */
define test_blkprintf()
{
	local A, B;

	print '7000: Beginning test_blkprintf';
	A = blk("alpha");
	print				  '7001: A = blk("alpha")';
	B = blk();
	print				  '7002: B = blk();';
	copy("abc yz", A);
	print				  '7003: copy("abc yz", A);';
	copy("defg", B);
	print				  '7004: copy("defg", B);';
	vrfy(strprintf("%s", A) == "abc yz",
			'7005: strprintf("%s", A) == "abc yz"');
	vrfy(strprintf("%s", A[2]) == "c yz",
			'7006: strprintf("%s", A[2]) == "c yz"');
	vrfy(strprintf("%s", A[7]) == "",
			'7007: strprintf("%s", A[7]) == ""');
	vrfy(strprintf("%c", A) ==  "a",
			'7008: strprintf("%c", A == "a"');
	vrfy(strprintf("%c", A[4]) ==  "y",
			'7009: strprintf("%c", A[4]) == "y"');
	vrfy(strprintf("%s", B) == "defg",
			'7010: strprintf("%s", B) == "defg"');
	vrfy(strprintf("%s", B[1]) == "efg",
			'7011: strprintf("%s", B[1]) == "efg"');
	vrfy(strprintf("%s", B[7]) == "",
			'7012: strprintf("%s", B[7]) == ""');
	vrfy(strprintf("%c", B) == "d",
			'7013: strprintf("%c", B == "d"');
	vrfy(strprintf("%c", B[2]) == "f",
			'7014: strprintf("%c", B[2]) == "f"');

	print '7015: Ending test_blkprintf';
}
print '172: parsed test_blkprintf()';


/*
 * test_sha1 - test the sha1 hash
 */
define test_sha1()
{
	local a, b, c, d, e, f, x, y, z, L, M, B;

	print '7200: Beginning test_sha1';
	y = sha1();
	print				'7201: y = sha1();';
	z = sha1();
	print				'7202: z = sha1();';
	vrfy(y == z,			'7203: y == z');
	z = sha1(1);
	print				'7204: z = sha1(1);';
	vrfy(sha1(y,1) == z,		'7205: sha1(y,1) == z');
	vrfy(sha1(z,2) == sha1(1,2),	'7206: sha1(z,2) == sha1(1,2)');
	vrfy(sha1(sha1()) == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709,
	    '7207: sha1(sha1()) == 0xda39a3ee5e6b4b0d3255bfef95601890afd80709');
	vrfy(sha1("x", "y", "z") == sha1("xyz"),
	    '7208: sha1("x", "y", "z") == sha1("xyz")');

	vrfy(sha1(sha1("this is",7^19-8,"a composit",3i+4.5,"hash")) ==
	    0xc3e1b562bf45b3bcfc055ac65b5b39cdeb6a6c55,
	'7209: sha1(sha1("this is",7^19-8,"a composit",3i+4.5,"hash")) == ...');


	z = sha1(list(1,2,3), "curds and whey", 2^21701-1, pi(1e-100));
	print '7210: z = sha1(list(1,2,3), "curds and whey", 2^21701-1, pi(1e-100));';
	vrfy(sha1(z) == 0x158cc87deeb9dd478ca14e3ab359205b0fb15b83,
		'7211: sha1(z) == 0x158cc87deeb9dd478ca14e3ab359205b0fb15b83');

	y = sha1();
	print '7212: y = sha1();';
	y = sha1(y, list(1,2,3), "curds and whey");
	print '7213: y = sha1(y, list(1,2,3), "curds and whey");';
	y = sha1(y, 2^21701-1);
	print '7214: y = sha1(y, 2^21701-1);';
	y = sha1(y, pi(1e-100));
	print '7215: y = sha1(y, pi(1e-100));';
	vrfy(y == z, '7216: y == z');

	vrfy(sha1(sha1("a"))==0x86f7e437faa5a7fce15d1ddcb9eaeaea377667b8,
	'7217: sha1(sha1("a"))==0x86f7e437faa5a7fce15d1ddcb9eaeaea377667b8');

	vrfy(sha1(sha1("ab"))==0xda23614e02469a0d7c7bd1bdab5c9c474b1904dc,
	'7218: sha1(sha1("ab"))==0xda23614e02469a0d7c7bd1bdab5c9c474b1904dc');
	vrfy(sha1(sha1("abc"))==0xa9993e364706816aba3e25717850c26c9cd0d89d,
	'7219: sha1(sha1("abc"))==0xa9993e364706816aba3e25717850c26c9cd0d89d'
	);
	vrfy(sha1(sha1("abcd"))==0x81fe8bfe87576c3ecb22426f8e57847382917acf,
	'7220: sha1(sha1("abcd"))==0x81fe8bfe87576c3ecb22426f8e57847382917acf');
	vrfy(sha1(sha1("abcde"))==0x03de6c570bfe24bfc328ccd7ca46b76eadaf4334,
    '7221: sha1(sha1("abcde"))==0x03de6c570bfe24bfc328ccd7ca46b76eadaf4334');
	vrfy(sha1(sha1("abcdef"))== 0x1f8ac10f23c5b5bc1167bda84b833e5c057a77d2,
    '7222: sha1(sha1("abcdef"))==0x1f8ac10f23c5b5bc1167bda84b833e5c057a77d2');
	vrfy(sha1(sha1("abcdefg"))==0x2fb5e13419fc89246865e7a324f476ec624e8740,
    '7223: sha1(sha1("abcdefg"))==0x2fb5e13419fc89246865e7a324f476ec624e8740');
	vrfy(sha1(sha1("abcdefgh"))==0x425af12a0743502b322e93a015bcf868e324d56a,
    '7224: sha1(sha1("abcdefgh"))==0x425af12a0743502b322e93a015bcf868e324d56a');

	vrfy(sha1(sha1(1))==0x53dd4e1734ad47d45e41c23e4ce42d7f1f98c1e8,
	    '7225: sha1(sha1(1))==0x53dd4e1734ad47d45e41c23e4ce42d7f1f98c1e8');
	vrfy(sha1(sha1(22/7))==0xf8e2510f85f7b9bf088b321188e9f70620f44246,
	'7226: sha1(sha1(22/7))==0xf8e2510f85f7b9bf088b321188e9f70620f44246');
	vrfy(sha1(sha1(isqrt(2e1000)))==
	    0x6852a1365c51050c3d039e3c5d9cf29c12283ef4,
  '7227: sha1(sha1(isqrt(2e1000)))==0x6852a1365c51050c3d039e3c5d9cf29c12283ef4'
  );
	L = list(1,2,3);
	print				'7228: L = list(1,2,3)';
	mat M[3] = {4,5,6};
	print				'7229: mat M[3] = {4,5,6}';
	B = blk() = {7,8,9};
	print				'7230: B = blk() = {7,8,9}';
	vrfy(sha1(sha1(L), M, B) == sha1(L, M, B),
		'7231: sha1(sha1(L), M, B) == sha1(L, M, B)');
	vrfy(sha1(sha1(L,M), B) == sha1(L, M, B),
		'7232: sha1(sha1(L, M), B) == sha1(L, M, B)');

	print '7233: Ending test_sha1';
}
print '174: parsed test_sha1()';


/*
 * The 7400's contain tests for saveval and dot.  These tests are
 * done inline near the bottom.
 */


/*
 * test_ptr - test pointers
 */
define g7500a(a,b) = a = b;
print '176: define g7500a(a,b) = a = b';
define g7500b(a,b) = a + b;
print '177: define g7500b(a,b) = a + b';
define g7500c(a,b) = *(a + b);
print '178: define g7500c(a,b) = *(a + b)';
define g7500d(a) = &a;
print '179: define g7500d(a) = &a';
define g7500e(a,b) = *a = b;
print '180: define g7500e(a,b) = *a = b'
define test_ptr()
{
	local a, b, c, A, B, B1, B2, M, L, p, q, p0, q0;

	print '7500: Beginning test_ptr';

	vrfy(isoctet(27) == 0,		'7501: isoctet(27) == 0');
	vrfy(isptr(27) == 0,		'7502: isptr(27) == 0');

	/* testing octet pointers */

	B = blk() = {1,2,3,4,5,6};
	print				'7503: B = blk() = {1,2,3,4,5,6};';
	vrfy(isoctet(B[0]) == 1,	'7504: isoctet(B[0]) == 1');
	vrfy(isnum(B[0]) == 0,		'7505: isnum(B[0]) == 0');
	vrfy(isptr(B[0]) == 0,		'7506: isptr(B[0]) == 0');
	vrfy(isoctet(*B[0]) == 0,	'7507: isoctet(*B[0]) == 0');
	vrfy(isnum(*B[0]) == 1,		'7508: isnum(*B[0]) == 1');
	vrfy(isoctet(&B[0]) == 0,	'7509: isoctet(&B[0]) == 0');
	vrfy(isptr(&B[0]) == 1,		'7510: isptr(&B[0]) == 1');
	vrfy(*B[3] == B[3],		'7511: *B[3]== B[3]');
	vrfy(*&B[3] == B[3],		'7512: *&B[3] == B[3]');
	vrfy(&B[0] + 3 == &B[3],	'7513: &B[0] + 3 == &B[3]');
	vrfy(&B[3] - &B[0] == 3,	'7514: &B[3] - &B[0] == 3');
	vrfy(&B[3] - 3 == &B[0],	'7515: &B[3 - 3 == &B[1]');
	vrfy(&B[3] > &B[0],		'7516: &B[3] > &B[0]');
	swap(B[0], B[5]);
	print				'7517: swap(B[0], B[5]);';
	vrfy(B[0] == 6 && B[5] == 1,	'7518: B[0] == 6 && B[5] == 1');

	/* testing octet-pointer-valued variables */

	p = &B[0], q = &B[5];
	print				'7519: p = &B[0], q = &B[5]';
	vrfy(isoctet(p) == 0,		'7520: isoctet(p) == 0');
	vrfy(isptr(p) == 1,		'7521: isptr(p) == 1');
	vrfy(isoctet(*p) == 1,		'7522: isoctet(*p) == 1');
	vrfy(isptr(*p) == 0,		'7523: isptr(*p) == 0');
	vrfy(p == &B[0],		'7524: p == &B[0]');
	vrfy(q != p,			'7525: q != p');
	vrfy(q > p,			'7526: q > p');
	vrfy(*p == B[0],		'7527: *p == B[0]');
	vrfy(&B[1] == p + 1,		'7528: &B[1] == p + 1');
	vrfy(q == p + 5,		'7529: q == p + 5');
	*p = 1, *q = 6;
	print				'7530: *p = 1, *q = 6';
	vrfy(B[0] == 1 && B[5] == 6,	'7531: B[0] == 1 && B[5] == 6');
	a = *p, b = *q;
	print				'7532: a = *p, b = *q';
	vrfy(a == 1 && b == 6,		'7533: a == 1 && b == 6');
	*(p + 3) = 7;
	print				'7534: *(p + 3) = 7;';
	vrfy(B[3] == 7,			'7535: B[3] == 7');
	*(q - 2) = 8;
	print				'7536: *(q - 2) = 8;';
	vrfy(B[3] == 8,			'7537: B[3] == 8');
	p0 = p++;
	print				'7538: p0 = p++;';
	vrfy(p0 == &B[0] && p == &B[1], '7539: p0 == &B[0] && p == &B[1]');
	q0 = --q;
	print				'7540: q0 = --q';
	vrfy(q0 == &B[4] && q == q0,	'7541: q0 == &B[4] && q == q0');
	a = *p++, b = *q--;
	print				'7542: a = *p++, b = *q--;';
	vrfy(a == 2 && b == 5,		'7543: a == 2 && b == 5');
	vrfy(p - &B[0] == 2 && q == &B[0] + 3,
				'7544: p - &B[0] == 2 && q == &B[0] + 3');
	a = *--q, b = *----q;
	print				'7545: a = *--q, b = *----q;';
	vrfy(q == &B[0],		'7546: q == &B[0]');
	vrfy(a == 3 && b == 1,		'7547: a == 3 && b == 1');
	a = (*p)++;
	print				'7548: a = (*p)++;';
	vrfy(a == 3 && B[2] == 4,	'7549: a == 3 && B[2] == 4');
	a = ++(*++p)++;
	print				'7550: a = ++(*++p)++;';
	vrfy(a == 9 && B[3] == 10,	'7551: a == 9 && B[3] == 10');

	/* testing octets, & and * in arguments of user-defined functions */

	A = blk() = {1,2,3};
	print				'7552: A = blk() = {1,2,3};';
	vrfy(g7500a(A[0],5) == 5,	'7553: g7500a(A[0],5) == 5');
	vrfy(A[0] == 5,			'7554: A[0] == 5');
	vrfy(g7500a(`A[0],5) == 5,	'7555: g7500a(`A[0],5) == 5');
	vrfy(A[0] == 5,			'7556: A[0] == 5');
	vrfy(g7500b(&A[0],3) == &A[3],	'7557: g7500b(&A[0],3) == &A[3]');
	vrfy(g7500c(&A[0],2) == 3,	'7558: g7500c(&A[0], 2) == 3');
	vrfy(g7500d(`A[0]) == &A[0],	'7559: g7500d(`A[0]) == &A[0]');
	p = &A[0];
	print				'7560: p = &A[0];';
	vrfy(g7500a(*p, 6) == 6,	'7561: g7500a(*p, 6) == 6');
	vrfy(*p == 6,			'7562: *p == 6');
	vrfy(g7500a(`*p,6) == 6,	'7563: g7500a(`*p,6) == 6');
	vrfy(*p == 6,			'7564: *p == 6');
	vrfy(g7500b(p,3) == p + 3,	'7565: g7500b(p,3) == p + 3');
	vrfy(g7500c(p,2) == 3,		'7566: g7500c(p,2) == 3');
	vrfy(g7500d(`*p) == p,		'7567: g7500d(`*p) == p');
	vrfy(g7500e(p,4) == 4,		'7568: g7500e(p,4) == 4');
	vrfy(A[0] == 4,			'7569: A[0] == 4');
	vrfy(g7500e(p+2,5) == 5,	'7570: g7500e(p+2,5) == 5');
	vrfy(A[2] == 5,			'7571: A[2] == 5');

	/* testing pointers to values */

	A = 27, p = &A;
	print				'7572: A = 27, p = &A;';
	vrfy(isptr(A) == 0,		'7573: isptr(A) == 0');
	vrfy(isptr(&A) == 2,		'7574: isptr(&A) == 2');
	vrfy(isptr(p) == 2,		'7575: isptr(p) == 2');
	vrfy(*p == 27,			'7576: *p == 27');
	vrfy(p == &A,			'7577: p == &A');
	*p = 45;
	print				'7578: *p = 45;';
	vrfy(A == 45,			'7579: A == 45');
	q = p;
	print				'7580: q = p;';
	vrfy(q == &A,			'7581: q == &A');
	q = &p;
	print				'7582: q = &p';
	vrfy(*q == p,			'7583: *q == p');
	vrfy(**q == A,			'7584: **q == A');
	vrfy(***q == A,			'7585: ***q == A');
	M = mat[4] = {1,2,3,4};
	print				'7586: M = mat[4] = {1,2,3,4};';
	p = &M[0], *p = 5;
	print				'7587: p = &M[0], *p = 5;';
	vrfy(M[0] == 5,			'7588: M[0] == 5');
	*++p = 6;
	print				'7589: *++p = 6;';
	vrfy(M[1] == 6,			'7590: M[1] == 6');
	q = p++;
	print				'7591: q = p++;';
	vrfy(q == &M[1],		'7592: q == &M[1]');
	vrfy(p == &M[2],		'7593: p == &M[2]');
	quomod(17,5,*q,*p);
	print				'7594: quomod(17,5,*p,*q);';
	vrfy(M[1] == 3 && M[2] == 2,	'7595: M[1] == 3 && M[2] == 2');
	swap(*p, *q);
	print				'7596: swap(*p, *q);';
	vrfy(M[1] == 2 && M[2] == 3,	'7597: M[1] == 2 && M[2] == 3');
	A = *M = {7,8};
	print				'7598: A = *M = {7,8};';
	vrfy(M == (mat[4] = {5,2,3,4}), '7599: M == (mat[4] = {5,2,3,4})');
	vrfy(A == (mat[4] = {7,8,3,4}), '7600: A == (mat[4] = {7,8,3,4})');

	/* Values which point to themselves */

	A = &A;
	print				'7601: A = &A;';
	vrfy(&A == A && *A == A,	'7602: &A == A && *A == A');
	A = &B, B = &A;
	print				'7603: A = &B, B = &A;';
	vrfy(**A == A && ***A == B,	'7604: **A == A && ***A == B');

	/* Testing functions that return pointers */

	M[3] = 7;
	print				'7605: M[3] = 7;';
	vrfy(*g7500b(&M[1], 2) == 7,	'7606: *g7500b(&M[1], 2) == 7');

	*g7500b(&M[1], 2) = 8;
	print				'7607: *g7500b(&M[1], 2) = 8;';
	vrfy(M[3] == 8,			'7608: M[3] == 8');
	M[3] = list(9,10);
	print				'7609: M[3] = list(9,10);';
	vrfy((*g7500b(&M[1], 2))[[1]] == 10,
				'7610: (*g7500b(&M[1], 2))[[1]] == 10');

	/* Testing number and string pointers */

	a = 24, b = 4 * 6, c = 4!;
	print				'7611: a = 24, b = 4 * 6, c= 4!;';
	vrfy(isptr(&*a) == 4,		'7612: isptr(&*a) == 4');
	vrfy(&*a == &24,		'7613: &*a == &24');
	vrfy(&*a == &*b,		'7614: &*a == &*b');
	vrfy(&*a != &*c,		'7615: &*a != &*c');

	a = b = "abc", c = strcat("a", "bc");
	print			'7616: a = b = "abc", c = strcat("a", "bc");';
	vrfy(isptr(&*a) == 3,		'7617: isptr(&*a) == 3');
	vrfy(&*a == &"abc",		'7618: &*a == &"abc"');
	vrfy(&*a == &*b,		'7619: &*a == &*b');
	vrfy(&*a != &*c,		'7620: &*a != &*c');
	a = c;
	print				'7621: a = c;';
	vrfy(&*a == &*c,		'7622: &*a == &*c');

	/* Verifying null-ness of freed numbers */

	c = 4!, p = &*c, free(c);
	print				'7623: c = 4!, p = &*c, free(c)';
	vrfy(isnull(*p),		'7624: isnull(*p)');

	print '7625: Ending test_ptr';
}
print '181: parsed test_ptr()';


/*
 * test_newstring - test new string operations
 */
define test_newstring()
{
	local A, B, C, D, S, p, q;

	print '7700: Beginning test_newstring';

	A = "abcdef", B = "xyz";
	print				'7701: A = "abcdef", B = "xyz";';
	vrfy(A + B == "abcdefxyz",	'7702: A + B == "abcdefxyz"');
	vrfy(-A == "fedcba",		'7703: -A == "fedcba"');
	vrfy(A - B == "abcdefzyx",	'7704: A - B == "abcdefzyx"');
	vrfy(2 * B == "xyzxyz",		'7705: 2 * B == "xyzxyz"');
	vrfy(-2 * B == "zyxzyx",	'7706: -2 * B == "zyxzyx"');
	vrfy(B * 3 == "xyzxyzxyz",	'7707: B * 3 == "xyzxyzxyz"');
	vrfy(2.5 * B == "xyzxyzx",	'7708: 2.5 * B == "xyzxyzx"');
	vrfy(0 * B == "",		'7709: 0 * B == ""');
	vrfy(3 * "12" == "121212",	'7710: 2 * "12" == "121212"');
	vrfy(A/2 == "abc",		'7711: A/2 == "abc"');
	vrfy(A | B == "y\173\173def",	'7712: A | B == "y\\173\\173def"');
	vrfy(A & B == "``b",		'7713: A & B == "``b"');
	vrfy(A \ B == "\1\2\1def",	'7714: A \\ B == "\\1\\2\\1def"');
	vrfy(A ~ B == "\31\e\31def",	'7715: A ~ B == "\\31\\e\\31def"');
	vrfy(~B == "\207\206\205",	'7716: ~B == "\\207\\206\\205"');
	C = "abcdef";
	print				'7717: C = "abcdef";';
	vrfy(&*A == &*C,		'7718: &*A == &*C');
	D = "abc\0ef";
	print				'7719: D = "abc\0ef;"';
	vrfy(size(D) == 6,		'7720: size(D) == 6');
	vrfy(strlen(D) == 3,		'7721: strlen(D) == 3');
	vrfy(strcat(D,B) == "abcxyz",	'7722: strcat(D,B) == "abcxyz"');

	vrfy(bit(A,0) == 1,		'7723: bit(A,0) == 1');
	vrfy(!bit(A,12),		'7724: !bit(A,12)');
	vrfy(bit(A,13),			'7725: bit(A,13)');
	vrfy(lowbit(A) == 0,		'7726: lowbit(A) == 0');
	vrfy(highbit(A) == 46,		'7727: highbit(A) == 46');
	vrfy(#A == 21,			'7728: #A == 21');

	vrfy(A[2] == "c",		'7729: A[2] == "c"');
	vrfy(char(A[2]) == "c",		'7730: char(A[2]) == "c"');
	vrfy(A[2] == 99,		'7731: A[2] == 99');
	vrfy(ord(A[2]) == 99,		'7731: ord(A[2]) == 99');
	vrfy(A[2] == A[0] + 2,		'7732: A[2] == A[0] + 2');
	vrfy(3 * A[2] == 297,		'7733: 3 * A[2] == 297');
	vrfy(3 * char(A[2]) == "ccc",	'7734: 3 * char(A[2]) == "ccc"');

	vrfy(head(A,3) == "abc",	'7735: head(A,3) == "abc"');
	vrfy(head(A,-3) == "cba",	'7736: head(A,-3) == "cba"');
	vrfy(tail(A,3) == "def",	'7737: tail(A,3) == "def"');
	vrfy(tail(A,-3) == "fed",	'7738: tail(A,-3) == "fed"');
	vrfy(segment(A,2) == "c",	'7739: segment(A,2) == "c"');
	vrfy(segment(A,2,4) == "cde",	'7740: segment(A,2,4) == "cde"');
	vrfy(segment(A,4,2) == "edc",	'7741: segment(A,4,2) == "edc"');

	vrfy(search(A, "c") == 2,	'7742: search(A, "c") == 2');
	vrfy(search(A, "x") == null(),	'7743: search(A, "x") == null()');
	vrfy(search("abbcbc", "bc") == 2,
			'7744: search("abbcbc", "bc") == 2');
	vrfy(search("abbcbc", "bc", 2) == 2,
			'7745: search("abbcbc", "bc", 2) == 2');
	vrfy(search("abbcbc", "bc", 3) == 4,
			'7746: search("abbcbc", "bc", 3) == 4');
	vrfy(search("abbcbc", "bc", -3) == 4,
			'7747: search("abbcbc", "bc", -3) == 4');
	vrfy(search("abbcbc", "bc", -4) == 2,
			'7748: search("abbcbc", "bc", -4) == 2');
	vrfy(search("abbcbc", "bc", , 3) == null(),
			'7749: search("abbcbc", "bc", , 3) == null()');
	vrfy(search("abbcbc", "bc", , 4) == 2,
			'7750: search("abbcbc", "bc", , 4) == 2');

	vrfy(rsearch("abbcbc", "bc") == 4,
			'7751: rsearch("abbcbc", "bc") == 4');

	p = &A[0];
	print				'7752: p = &A[0];';
	vrfy(-*p == -97,		'7753: -*p == -97');
	vrfy(~*p == char(158),		'7754: ~*p == char(158)');
	vrfy(/-#~*p == -1/5,		'7755: /-#~*p == -1/5');

	A[0] = "A";
	print				'7756: A[0] = "A";';
	vrfy(A == "Abcdef",		'7757: A == "Abcdef"');
	A[1] = 173;
	print				'7758: A[1] = 173;';
	vrfy(A == "A\255cdef",		'7759: A == "A\\255cdef"');
	setbit(A, 18);
	print				'7760: setbit(A,10);';
	vrfy(A == "A\255gdef",		'7761: A == "A\\255gdef"');
	setbit(A, 16, 0);
	print				'7762: setbit(A, 16, 0);';
	vrfy(A == "A\255fdef",		'7763: A == "A\255fdef"');

	q = "curds" " and " "whey";
	print				'7764: q = "curds" " and " "whey"';
	vrfy(q == "curds and whey",	'7765: q == "curds and whey"');
	q = "chongo" ' was ' "here";
	print				'7766: q = "chongo" \' was \' "here"';
	vrfy(q == "chongo was here",	'7767: q == "chongo was here"');

	print '7768: Ending test_newstring';
}
print '182: parsed test_newstring()';



/*
 * test_newcomb - test combinatoric and permutation functions
 */
define test_newcomb()
{
	print '7800: Beginning test_newcomb';
	vrfy(comb(2, 5) == 0,		'7801: comb(2, 5) == 0');
	vrfy(comb(2, -2) == 0,		'7802: comb(2, -2) == 0');
	vrfy(comb(1/2, 4) == -5/128,	'7803: comb(1/2, 4) == -5/128');
	vrfy(comb(1/2, 5) == 7/256,	'7804: comb(1/2, 5) == 7/256');

	vrfy(perm(2, -1) == 1/3,	'7805: perm(2, -1) == 1/3');
	vrfy(perm(2, -2) == 1/12,	'7806: perm(2, -2) == 1/12');
	vrfy(perm(2, -3) == 1/60,	'7807: perm(2, -3) == 1/60');
	vrfy(perm(1/2, 4) == -15/16,	'7808: perm(1/2, 4) == -15/16');
	vrfy(perm(1/2, 5) == 105/32,	'7809: perm(1/2, 5) == 105/32');
	vrfy(perm(1/2,-1) == 2/3,	'7810: perm(1/2, -1) == 2/3');
	vrfy(perm(1/2,-2) == 4/15,	'7811: perm(1/2, -2) == 4/15');

	print '7812: Ending test_newcomb';
}
print '183: parsed test_newcomb()';


/*
 * The following functions f, g should be equal when b-a is an
 * integer, and n is any integer other than -1.
 */
define f7900(a,b,n)
{
	local s, x;

	if (a > b)
		return -f7900(b, a, n);
	for (s = 0, x = a; x < b; x++)
		s += perm(x, n);
	return s;
}
print '184: define f7900(a,b,n) {... }';
/**/
define g7900(a,b,n) = (perm(b, n + 1) - perm(a, n + 1))/(n + 1);
print '185: define g7900(a,b,n) = ...';


/*
 * test_bigcomb - test big combinations and permutations
 */
define test_bigcomb()
{
	local a, b, n, i, v1, v2;

	print '7900: Starting test_bigcomb';
	a = 1234/4321;
	print				'7901: a = 1234/4321';
	b = 3456/6543;
	print				'7902: b = 3456/6543';
	n = 47;
	print				'7903: n = 47';
	v1 = perm(a + b, n);
	print				'7904: v1 = perm(a + b, n)';
	v2 = 0;
	print				'7905: v2 = 0';
	for (i = 0; i <= n; i++)
		v2 += comb(n, i) * perm(a, i) * perm(b, n - i);
	print '7906: for (i=0;i<=n;i++) v2 += comb(n,i)*perm(a,i)*perm(b,n-i)';
	vrfy(v1 == v2,			'7910: v1 == v2');

	vrfy(f7900(-10,10,5) == g7900(-10,10,5),
			'7911: f7900(-10,10,5) == g7900(10,10,5)');
	vrfy(f7900(5,15,-4) == g7900(5,15,-4),
			'7912: f7900(5,15,-4) == g7900(5,15,-4)');
	vrfy(f7900(-7/4,33/4,-2) == g7900(-7/4,33/4,-2),
			'7913: f7900(-7/4,33/4,-2) == g7900(-7/4,33/4,-2)');

	print '7914: Ending test_bigcomb';
}
print '186: parsed test_bigcomb()';


/*
 * natnumset - test natural numbers not exceeding a fixed bound
 */
read -once natnumset;
print '187: read -once natnumset;';
/**/
define test_natnumset()
{
	local A, B, C, D, P, P1, L1, L2;

	print '8000: Starting test_natnumset';

	A = set(17, 2, 0, 24, 2);
	print				'8101: A = set(17, 2, 0, 24, 2);';
	B = set(41, 17, 11, 2, 19, 17);
	print				'8102: B = set(41, 17, 11, 2, 19, 17);';
	vrfy(A | B == set(0,2,11,17,19,24,41),
			'8103: A | B == set(0,2,11,17,19,24,41)');
	vrfy(A & B == set(2,17),	'8104: A & B == set(2,17)');
	vrfy(A \ B == set(0,24),	'8105: A \\ B == set(0, 24)');
	vrfy(B \ A == set(11,19,41),	'8106: B \\ A == set(11,19,41)');
	vrfy(A ~ B == set(0,11,19,24,41),
			'8107: A ~ B == set(0,11,19,24,41)');
	vrfy(#A == 4,			'8108: #A == 4');
	vrfy(#~A == 97,			'8109: #~A == 97');
	vrfy(A + 5 == set(5,7,22,29),	'8110: A + 5 == set(5,7,22,29)');
	vrfy(A - 5 == set(12,19),	'8111: A - 5 == set(12,19)');
	vrfy(30 - A == set(6,13,28,30), '8112: 30 - A == set(6,13,28,30)');
	vrfy(2 * A == set(0,4,34,48),	'8113: 2 * A == set(0,4,34,48)');
	vrfy(10 * A == set(0,20),	'8114: 10 * A == set(0,20)');
	vrfy(A + A == set(0,2,4,17,19,24,26,34,41,48),
			'8115: A + A == set(0,2,4,17,19,24,26,34,41,48)');
	vrfy(A - A == set(0,2,7,15,17,22,24),
			'8116: A - A == set(0,2,7,15,17,22,24)');
	vrfy(set(2,3,5,7)^2 == set(4,9,25,49),
			'8117: set(2,3,5,7)^2 == set(4,9,25,49)');
	vrfy(interval(8,12) == set(8,9,10,11,12),
			'8118: interval(8,12) == set(8,9,10,11,12)');
	vrfy(min(A) == 0,		'8119: min(A) == 0');
	vrfy(max(A) == 24,		'8120: max(A) == 24');
	P = primes();
	print				'8121: P = primes();';
	vrfy(#P == 25,			'8122: #P == 25');
	vrfy(+P == 1060,		'8123: +P == 1060');
	vrfy(isin(P,31),		'8124: isin(P,31)');
	vrfy(!isin(P,51),		'8125: !isin(P,51)');
	P1 = primes(20,40);
	print				'8126: P1 = primes(20,40)';
	vrfy(P1 == set(23,29,31,37),	'8127: P1 == set(23,29,31,37)');
	vrfy(P1 < P,			'8128: P1 < P');
	vrfy(P1 & (set(3) % 4) == set(23,31),
			'8129: P1 & (set(3) % 4) == set(23,31)');

	L1 = list(3,2,1);
	print				'8130: L1 = list(3,2,1);';
	C = set(2,3,5,7);
	print				'8131: C = set(2,3,5,7);';
	vrfy(polyvals(L1, C) == set(11,18,38,66),
			'8132: polyvals(L1, C) == set(11,18,38,66)');
	L2 = list(0,list(0,1),1);
	print				'8133: L2 = list(0,list(0,1),1);';
	D = set(4,6);
	print				'8134: D = set(4,6);';

	vrfy(polyvals2(L2,C,D) == set(12,16,21,27,45,55,77,91),
		'8135: polyvals(L2,C,D) == set(12,16,21,27,45,55,77,91)');

	print '8136: Ending test_natnumset';
}
print '188: parsed test_natnumset()';


/*
 * test_somenew - test some new features
 */
define func8200(x,y) {if (x>0) return calclevel()+func8200(x-1,y)-y; return 0;}
print '189: define func8200(x,y)';
define test_somenew()
{
	local a, s, y;

	print	'8200: Starting test_somenew';

	vrfy(char(-1) == char(255),	'8201: char(-1) == char(255)');
	vrfy(char(258) == char(2),	'8202: char(258) == char(2)');

	vrfy(size(char(0)) == 1,	'8203: size(char(0)) == 1');
	vrfy(strlen(char(0)) == 0,	'8204: strlen(char(0)) == 0');
	vrfy(char(0) != "",		'8205: char(0) != ""');
	vrfy(str(char(0)) == "",	'8206: str(char(0)) == ""');

	vrfy(str("abc") == "abc",	'8207: str("abc") == "abc"');

	vrfy(2^-3^2 == 1/512,		'8208: 2^-3^2 == 1/512');
	vrfy(/2 == .5,			'8209: /2 == .5');
	vrfy(/-2 == -.5,		'8210: /-2 == -.5');
	vrfy(1+/2 == 1.5,		'8211: 1+/2 == 1.5');

	ecnt += 6;
	print				'8212: ecnt += 6';
	vrfy(0^-2 == 1/0,		'8213: 0^-2 == 1/0');
	vrfy(inverse(0) == 1/0,		'8214: inverse(0) == 1/0');
	vrfy(1/(1/0) == 0,		'8215: 1/(1/0) == 0');
	vrfy(inverse(1/0) == 0,		'8216: inverse(1/0) == 0');

	a = isqrt(2e1000); s = "xyz";
	print				'8217: a = isqrt(2e1000); s = "xyz";';
	vrfy(hash(a,s) == 2708885378,	'8218: hash(a,s) == 2708885378');
	vrfy(hash("curds n whey") == 2376141927,
			'8219: hash("curds n whey") == 2376141927');

	y = calclevel();
	print				'8220: y = calclevel()';
	vrfy(func8200(0,y) == 0,	'8221: func8200(0,y) == 0');
	vrfy(func8200(1,y) == 1,	'8222: func8200(1,y) == 1');
	vrfy(func8200(10,y) == 55,	'8223: func8200(10,y) == 55');
	vrfy(func8200(100,y) == 5050,	'8224: func8200(100,y) == 5050');

	vrfy(inputlevel() == 1,		'8225: inputlevel() == 1');

	print '8226: Ending test_somenew';
}
print '190: parsed test_somenew()';


/*
 * test_exponentiation - test new exponentiation functionaltiy
 */
define test_exponentiation()
{
	local a;

	print	'8800: Starting test_somenew';

	/* unexpected help file cases */
	vrfy(2^3 == 8,			'8801: 2^3 == 8');
	vrfy(2.5 ^ 3.5 == power(2.5, 3.5),
			'8802: 2.5 ^ 3.5 == power(2.5, 3.5)');
	vrfy(2.5 ^ 2.718i == power(2.5, 2.718i),
			'8803: 2.5 ^ 2.718i == power(2.5, 2.718i)');
	vrfy(3i^4 == 81,		'8804: 3i^4 == 81');
	vrfy(0.5i ^ 0.25 == power(0.5i, 0.25),
			'8804: 0.5i ^ 0.25 == power(0.5i, 0.25)');
	vrfy(3.13145i^0.30103i == power(3.13145i, 0.30103i),
			'8806: 3.13145i^0.30103i == power(3.13145i, 0.30103i)');

	/* deal with some corner error cases */
	ecnt += 12;
	print				'8807: ecnt += 2';
	vrfy((1/0) ^ -1 == 0,		'8808: (1/0) ^ -1 == 0');
	vrfy((1/0) ^ -2 == 0,		'8809: (1/0) ^ -2 == 0');
	vrfy((1/0) ^ 0 == error(10001),	'8810: (1/0) ^ 0 == error(10001)');
	vrfy((1/0) ^ 3 == error(10001),	'8811: (1/0) ^ 3 == error(10001)');
	vrfy(0 ^ -2 == error(10001),	'8812: 0 ^ -2 == error(10001)');
	vrfy((1/0) ^ 1i == error(10001),'8813: (1/0) ^ 1i == error(10001)');
	vrfy((1/0) ^ 0i == error(10001),'8814: (1/0) ^ 0i == error(10001)');

	/* real ^ real */
	vrfy(5^6 == 15625,		'8815: 5^6 == 15625');
	vrfy(10^31 == 1e31,		'8816: 10^31 == 1e31');
	vrfy(10 ^ (127/31) == power(10, 127/31),
			'8817: 10 ^ (127/31) == power(10, 127/31)');
	vrfy((10^31) ^ 10 == 1e310,	'8818: (10^31) ^ 10 == 1e310');

	/* complex ^ real */
	vrfy(10i ^ 10 == -1e10,		'8819: 10i ^ 10 == -1e10');
	vrfy((-10i) ^ 10 == -1e10,	'8820: (-10i) ^ 10 == -1e10');
	vrfy((1+1i) ^ 4 == -4,		'8821: (1+1i) ^ 4 == -4');
	vrfy((1+1i) ^ 65536 == 2^32768,	'8822: (1+1i) ^ 65536 == 2^32768');
	vrfy((1+1i) ^ (2^20) == 2^(2^19),
			'8823: (1+1i) ^ (2^20) == 2^(2^19)');
	vrfy((31+17i) ^ pi() == power(31+17i, pi()),
			'8824: (31+17i) ^ pi() == power(31+17i, pi()');
	vrfy((5+7i) ^ exp(5) == power(5+7i, exp(5)),
			'8825: (5+7i) ^ exp(5) == power(5+7i, exp(5))');

	/* real ^ complex */
	vrfy(10 ^ 1i == power(10, 1i), '8826: 10 ^ 1i == power(10, 1i)');
	vrfy(10 ^ (2+3i) == power(10, 2+3i),
			'8827: 10 ^ (2+3i) == power(10, 2+3i)');
	vrfy(pi() ^ (2+3i) == power(pi(), 2+3i),
			'8828: pi() ^ (2+3i) == power(pi(), 2+3i)');
	vrfy(exp(64) ^ (2+3i) == power(exp(64), 2+3i),
			'8828: exp(64) ^ (2+3i) == power(exp(64), 2+3i)');
	vrfy(pi() ^ (257+127i) == power(pi(), 257+127i),
			'8829: pi() ^ (257+127i) == power(pi(), 257+127i)');
	vrfy(pi() ^ asin(-2) == power(pi(), asin(-2)),
			'8830: pi() ^ asin(-2) == power(pi(), asin(-2)');

	/* complex ^ complex */
	vrfy((3+4i) ^ (2+3i) == power(3+4i, 2+3i),
			'8831: (3+4i) ^ (2+3i) == power(3+4i, 2+3i)');
	vrfy(ln(-10) ^ (2+3i) == power(ln(-10), 2+3i),
			'8832: ln(-10) ^ (2+3i) == power(ln(-10), 2+3i)');
	vrfy((pi()*1i) ^ asin(-2) == power(pi()*1i, asin(-2)),
		'8833: (pi()*1i) ^ asin(-2) == power(pi()*1i, asin(-2))');
	vrfy((exp(1)+pi()*1i) ^ asin(-2) == power(exp(1)+pi()*1i, asin(-2)),
	'8834: (exp(1)+pi()*1i) ^ asin(-2) == power(exp(1)+pi()*1i, asin(-2))');

	print '8835: Ending test_somenew';
}
print '191: parsed test_exponentiation()';


/*
 * test_quit - test the QUIT functionality
 */
define test_quit()
{
	local x8400 = 23209;	/* watch for lost memory */
	static s8400 = 21701;	/* watch for lost memory */

	print '8400: Starting test_quit';

	quit;
	prob('quit did not end the test_quit() function');

	/* 8400 serise continued after return, do not print end here */
}
print '191: parsed test_quit()';


/*
 * Reserved for top level test use
 */
print '200: Reserved for top level test use';


/*
 * Report the number of errors found.
 */
define count_errors()
{
	if (prob  ==  0) {
		print "9997: passed all tests  /\\../\\";
	} else {
		print "****", prob, "error(s) found  \\/++\\/";
	}
}
print '298: parsed count_errors()';


print '299: Ending main part of regression test suite read';


print;
return test_booleans();
print;
return test_variables();
print;
return test_arithmetic();
print;
return test_config();
print;
return test_bignums();
print;
return test_functions();
print;
return _test_underscore();
print;
return test_assoc();
print;
return test_list();
print;
return test_rand();
print;
return test_mode();
print;

print '1700: Beginning read test';
value = 0;
vrfy(value == 0,		  '1701: value == 0');
read "test1700";
print				  '1702: read "test1700";';
vrfy(value == 1,		  '1703: value == 1');
read -once "test1700";
print				  '1704: read -once "test1700";';
vrfy(value == 1,		  '1705: value == 1');
read "test1700.cal";
print				  '1706: read "test1700.cal";';
vrfy(value == 2,		  '1707: value == 2');
read -once "test1700.cal";
print				  '1708: read -once "test1700.cal";';
vrfy(value == 2,		  '1709: value == 2');
read "test1700.cal";
print				  '1710: read "test1700.cal";';
vrfy(value == 3,		  '1711: value == 3');
{++value;} read "test1700.cal";
print				  '1712: {++value;} read "test1700.cal";';
vrfy(value == 5,		  '1713: value == 5');
{++value;} read -once "test1700.cal";
print				  '1714: {++value;} read -once "test1700.cal";';
vrfy(value == 6,		  '1715: value == 6');
print '1716: Ending read test';

print;
return test_obj();
print;
return test_prime();
print;
return test_lucas();
print;
return test_newop();
print;
return test_xx_incdec();
print;
return test_round();
print;
return test_2600();
print;
return test_2700();
print;
return test_matrix();
print;
return test_strings();
print;
return test_matobj();
print;
return test_poly();
print;
return test_det();
print;
return test_trig();
print;
return test_frem();
print;
return test_error();
print;
return test_param();
print;
return test_noarg();
print;
return test_ptest();
print;
return test_redc();
print;
return test_fileops();
print;
return test_matdcl();
print;
return test_objmat();
print;
return test_fileop();
print;
return test_charset();
print;
return test_strprintf();
print;
return test_listsearch();
print;
return test_filesearch();
print;
return test_newdecl();
print;
return test_globstat();
print;
return test_random();
print;
return test_newsyn();

vrfy(s5500 == 78,		  '5548: s5500 == 78');

print;
return test_commaeq();
print;
return test_size();
print;

/*
 * 5800 assignment tests
 */
return test_assign(5800, 1);
define xy5800_assign(a,b) { };
print '5812: define xy5800_assign(a,b) { }';
return test_assign(5820, 0);
undefine xy5800_assign;
print '5832: undefine xy5800_assign';
return test_assign(5840, 1);
define xy5800_assign(a, b) = a.y = b;
print '5852: define xy5800_assign(a, b) = a.y = b';
X5800 = 9;
print '5853: X5800 = 9';
vrfy(X5800 == (obj xy5800 = {3,9}),
				  '5854: X5800 == (obj xy5800 = {3,9})');
asserr = newerror("Incompatible types for =");
print '5855: asserr = newerror("Incompatible types for =")';
define xy5800_assign(a, b) {
	if (istype(b, obj xy5800)) {
		a.x = b.x;
		a.y = b.y;
	} else if (isreal(b)) {
		a.x = b;
		a.y = 0;
	} else {
		error(asserr);
	}
}
print '5856: xy5800_assign(a, b) { ... };';
ecnt += 2;
print '5857: ecnt += 2';
X5800 = 2 + 3i;
print '5858: X5800 = 2 + 3i';
vrfy(X5800 == (obj xy5800 = {3,9}),
				  '5859: X5800 == (obj xy5800 = {3,9})');
vrfy(errno() > 0,		  '5860: errno() > 0');
vrfy(strerror() == "Incompatible types for =",
		'5861: strerror() == "Incompatible types for ="');
X5800 = 2;
print				  '5862: X5800 = 2';
vrfy(X5800 == (obj xy5800 = {2,0}),
			'5863: X5800 == (obj xy5800 = {2,0})');
X5800 = obj xy5800 = {1,2};
print				  '5864: X5800 = obj xy5800 = {1,2}';
vrfy(X5800 == (obj xy5800 = {1,2}),
				  '5865: X5800 == (obj xy5800 = {1,2})');
define f5800(a5800 = mat[2] = {3,4}) = 5 * a5800;
print		'5866: define f5800(a5800 = mat[2] = {3,4}) = 5 * a5800;'
vrfy(f5800() == (mat[] = {15,20}),'5867: f5800() == (mat[] = {15,20})');
print '5868: End of 5800 sequence';

print;
return test_is();
print;
return test_blk();
print;
return test_blkcpy();
print;
return test_name();
print;
return test_blkprintf();
print;
return test_sha1();
print;

print '7400: Beginning test_savedot';
print				'7401: saveval(1);';
saveval(1);
print				'7402: a7400 = 2;';
a7400 = 2;
vrfy(. == 2,			'7403: . == 2;');
vrfy((. += 3, . == 5),		'7404: (. += 3, . == 5)');
vrfy(. == 5,			'7405: . == 5;');
print				'7406: a7400 = 5; b7400 = 6;';
a7400 = 5; b7400 = 6;
vrfy(. == 6,			'7407: . == 6');
print				'7408: a7400 = 7; b7400 = 8; null()';
a7400 = 7; b7400 = 8; null();
vrfy(. == 6,			'7409: . == 6');
print				'7410: saveval(0);';
saveval(0);
print				'7411: a7400 = 9;';
a7400 = 9;
vrfy(. == 6,			'7412: . == 6');
print '7413: a7400 = 2; saveval(1); b7400 = 3; saveval(0); c7400 = 4;';
a7400 = 2; saveval(1); b7400 = 3; saveval(0); c7400 = 4;
vrfy(. == 3,			'7414: . == 3');
print				'7415: free(.);';
free(.);
vrfy(isnull(.),			'7416: isnull(.)');
print				'7417: a7400 = 4;';
a7400 = 4;
vrfy(isnull(.),			'7418: isnull(.)');
print				'7419: saveval(1);';
saveval(1);

print				'7420: obj pair7400 {one,two} = {1,2};';
obj pair7400 {one,two} = {1,2};
vrfy(. .one == 1,		'7421: . .one == 1');
print '7422: Ending test_savedot';

print;
return test_ptr();
print;
return test_newstring();
print;
return test_newcomb();
print;
return test_bigcomb();
print;
return test_natnumset();
print;
return test_somenew();


/*
 * misc define tests
 */
print;
print	'8300: Starting define tests';
define f8300(x) = x^2; define g8300(x) = 1 - x;
print	'8301: define f8300(x) = x^2; define g8300(x) = 1 - x;';
vrfy(f8300(10) == 100,		'8302: f8300(10) == 100');
vrfy(g8300(10) == -9,		'8303: g8300(10) == -9');
define h8300(x)=x^3;define i8300(x)=x-1;define j8300(x)=x+1;
print	'8304: define h8300(x)=x^3;define i8300(x)=x-1;define j8300(x)=x+1;';
vrfy(h8300(10) == 1000,		'8305: h8300(10) == 1000');
vrfy(i8300(10) == 9,		'8306: i8300(10) == 9');
vrfy(j8300(10) == 11,		'8307: j8300(10) == 11');
{static k8300 = 5} define l8300(x) = k8300 + x;
print	'8308: {static k8300 = 5} define l8300(x) = k8300 + x;';
vrfy(l8300(10) == 15,		'8309: l8300(10) == 15');
static a8300 = 1, b8300;
vrfy(a8300 == 1,		'8310: a8300 == 1');
print	'8311: Ending define tests';


/*
 * quit tests
 */
print;
return test_quit();
read -once test8400;
print	'8404: read -once test8400';
vrfy(test8400() == 64434,	'8405: test8400() == 64434');
print	'8406: Ending test_quit';


/*
 * test_divmod - psuedo-random tests on the // and % with various rounding modes
 */
print;
print '8500: Starting test of divmod'
read -once "test8500";
/* 85xx: Ending test of divmod is printed by test8500.cal */


/*
 * test_maxargs - test up to 1024 args being passed to a builtin function
 */
print;
print '8600: Starting test of up to 1024 args'
read -once "test8600";
/* 860x: Ending test of up to 1024 args is printed by test8600.cal */


/*
 * dupvar_warn and redecl_warn testing
 */
print;
print '8650: Starting test of dupvar_warn and redecl_warn config parameters';
vrfy(config("redecl_warn",0),	  '8651: config("redecl_warn",0)');
vrfy(config("dupvar_warn",0),	  '8652: config("dupvar_warn",0)');
vrfy(u_glob == 6,		  '8653: u_glob == 6');
global u_glob = 555;
print 				  '8654: reclare u_glob';
vrfy(u_glob == 555,		  '8655: u_glob == 555');
define func_8650(u_glob) { local u_glob; return u_glob; }
print				  '8656: u_glob a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    s both local and parameter';
define func_8650a(u_glob) { static u_glob; return u_glob; }
print				  '8657: u_glob as both static and parameter';
vrfy(config("redecl_warn",1)==0,  '8658: config("redecl_warn",1)==0');
vrfy(config("dupvar_warn",1)==0,  '8659: config("dupvar_warn",1)==0');
/* 865x: Ending test of up to 1024 args is printed by test8600.cal */


/*
 * dotest scripts
 *
 * We use the dotest driver to evaluate test-97xx data files.
 */
print;
print '8700: Starting dotest runs'
print '8701: read -once "dotest"';
read -once "dotest";
print '8702: read -once "set8700"';
read -once "set8700";
vrfy(dotest("set8700.line", 8703) == 0,
     '8703: dotest("set8700.line", 8703) == 0');
/* 87xx: Ending dotest runs is printed by set8700.test */


/*
 * new exponentiation functionaltiy
 */
print;
return test_exponentiation();
/* 88xx: test exponentiation */


/*
 * read various calc resource files
 *
 * We read most of the standard calc resource files.  There are a few
 * resource files that are not read:
 *
 *	beer.cal	- prints a bunch of things when loaded
 *	hello.cal	- designed to go into an infinite loop
 *	lucal.cal	- already read by this file
 *	lucas_chk.cal	- already read by this file
 *	lucas_tbl.cal	- duplicatres code already read by another file
 *	regress.cal	- this file
 *	surd.cal	- already read by this file
 *	test9999.cal	- files of this form are already read by this file
 *	xx_print.cal	- prints a bunch of things when loaded
 *
 * We want to do this 2nd to last; ahead of any final cleanup and behind
 * all of real actions of regress.cal.
 */
print;
print	'9800: Starting read of selected calc resource files';
read -once bernoulli;
print	'9801: read -once bernoulli';
read -once bigprime;
print	'9802: read -once bigprime';
read -once chrem;
print	'9803: read -once chrem';
read -once deg;
print	'9804: read -once deg';
read -once ellip;
print	'9805: read -once ellip';
read -once mersenne;
print	'9806: read -once mersenne';
read -once mfactor;
print	'9807: read -once mfactor';
read -once mod;
print	'9808: read -once mod';
read -once natnumset;
print	'9809: read -once natnumset';
read -once pell;
print	'9810: read -once pell';
read -once pi;
print	'9811: read -once pi';
read -once pix;
print	'9812: read -once pix';
read -once pollard;
print	'9813: read -once pollard';
read -once poly;
print	'9814: read -once poly';
read -once prompt;
print	'9815: read -once prompt';
read -once psqrt;
print	'9816: read -once psqrt';
read -once quat;
print	'9817: read -once quat';
read -once randbitrun;
print	'9818: read -once randbitrun';
read -once randmprime;
print	'9819: read -once randmprime';
read -once randombitrun;
print	'9820: read -once randombitrun';
read -once randomrun;
print	'9821: read -once randomrun';
read -once randrun;
print	'9822: read -once randrun';
read -once seedrandom;
print	'9823: read -once seedrandom';
read -once solve;
print	'9824: read -once solve';
read -once sumsq;
print	'9825: read -once sumsq';
read -once unitfrac;
print	'9826: read -once unitfrac';
read -once varargs;
print	'9827: read -once varargs';
read -once qtime;
print	'9828: read -once qtime';
read -once chi;
print	'9829: read -once chi';
read -once intfile;
print	'9830: read -once intfile';
read -once lucas;
print	'9831: read -once lucas';
read -once lucas_tbl;
print	'9832: read -once lucas_tbl';
read -once natnumset;
print	'9833: read -once natnumset';
read -once repeat;
print	'9834: read -once repeat';
read -once screen;
print	'9835: read -once screen';
read -once linear;
print	'9836: read -once linear';
print	'9837: skipping read -once beer.cal because it is an infinite loop';
print	'9838: skipping read -once hello.cal because it is an infinite loop';
print	'9839: skipping read -once xx_print.cal because it is a printing demo';
read -once sumtimes;
print	'9840: read -once sumtimes';
read -once dms;
print	'9841: read -once dms';
read -once hms;
print	'9842: read -once hms';
print	'9843: Ending read of selected calc resource files';


/*
 * cleanup and report the results
 */
print;
freeredc();
print '9995: freeredc()';
freestatics();
print '9996: freestatics()';
return count_errors();
freeglobals();
print '9998: freeglobals()';
print '9999: Ending regression tests';
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * pi - various routines to calculate pi
 *
 * Copyright (C) 1999-2004  David I. Bell
 *
 * Calc is open software; you can redistribute it and/or modify it under
 * the terms of the version 2.1 of the GNU Lesser General Public License
 * as published by the Free Software Foundation.
 *
 * Calc is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
 * Public License for more details.
 *
 * A copy of version 2.1 of the GNU Lesser General Public License is
 * distributed with calc under the filename COPYING-LGPL.  You should have
 * received a copy with calc; if not, write to Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * @(#) $Revision: 30.1 $
 * @(#) $Id: pi.cal,v 30.1 2007/03/16 11:09:54 chongo Exp $
 * @(#) $Source: /usr/local/src/cmd/calc/cal/RCS/pi.cal,v $
 *
 * Under source code control:	1991/05/22 21:56: