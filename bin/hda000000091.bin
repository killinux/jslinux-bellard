9)
* mpz_mul_2exp:                          Integer Arithmetic.  (line  35)
* mpz_mul_si:                            Integer Arithmetic.  (line  20)
* mpz_mul_ui:                            Integer Arithmetic.  (line  22)
* mpz_neg:                               Integer Arithmetic.  (line  39)
* mpz_nextprime:                         Number Theoretic Functions.
                                                              (line  23)
* mpz_odd_p:                             Miscellaneous Integer Functions.
                                                              (line  17)
* mpz_out_raw:                           I/O of Integers.     (line  43)
* mpz_out_str:                           I/O of Integers.     (line  16)
* mpz_perfect_power_p:                   Integer Roots.       (line  27)
* mpz_perfect_square_p:                  Integer Roots.       (line  36)
* mpz_popcount:                          Integer Logic and Bit Fiddling.
                                                              (line  23)
* mpz_pow_ui:                            Integer Exponentiation.
                                                              (line  31)
* mpz_powm:                              Integer Exponentiation.
                                                              (line   8)
* mpz_powm_sec:                          Integer Exponentiation.
                                                              (line  18)
* mpz_powm_ui:                           Integer Exponentiation.
                                                              (line  10)
* mpz_probab_prime_p:                    Number Theoretic Functions.
                                                              (line   7)
* mpz_random:                            Integer Random Numbers.
                                                              (line  42)
* mpz_random2:                           Integer Random Numbers.
                                                              (line  51)
* mpz_realloc2:                          Initializing Integers.
                                                              (line  52)
* mpz_remove:                            Number Theoretic Functions.
                                                              (line  90)
* mpz_root:                              Integer Roots.       (line   7)
* mpz_rootrem:                           Integer Roots.       (line  13)
* mpz_rrandomb:                          Integer Random Numbers.
                                                              (line  31)
* mpz_scan0:                             Integer Logic and Bit Fiddling.
                                                              (line  37)
* mpz_scan1:                             Integer Logic and Bit Fiddling.
                                                              (line  38)
* mpz_set:                               Assigning Integers.  (line  10)
* mpz_set_d:                             Assigning Integers.  (line  13)
* mpz_set_f:                             Assigning Integers.  (line  15)
* mpz_set_q:                             Assigning Integers.  (line  14)
* mpz_set_si:                            Assigning Integers.  (line  12)
* mpz_set_str:                           Assigning Integers.  (line  21)
* mpz_set_ui:                            Assigning Integers.  (line  11)
* mpz_setbit:                            Integer Logic and Bit Fiddling.
                                                              (line  51)
* mpz_sgn:                               Integer Comparisons. (line  28)
* mpz_si_kronecker:                      Number Theoretic Functions.
                                                              (line  77)
* mpz_size:                              Integer Special Functions.
                                                              (line  68)
* mpz_sizeinbase:                        Miscellaneous Integer Functions.
                                                              (line  23)
* mpz_sqrt:                              Integer Roots.       (line  17)
* mpz_sqrtrem:                           Integer Roots.       (line  20)
* mpz_sub:                               Integer Arithmetic.  (line  12)
* mpz_sub_ui:                            Integer Arithmetic.  (line  14)
* mpz_submul:                            Integer Arithmetic.  (line  30)
* mpz_submul_ui:                         Integer Arithmetic.  (line  32)
* mpz_swap:                              Assigning Integers.  (line  37)
* mpz_t:                                 Nomenclature and Types.
                                                              (line   6)
* mpz_tdiv_q:                            Integer Division.    (line  41)
* mpz_tdiv_q_2exp:                       Integer Division.    (line  52)
* mpz_tdiv_q_ui:                         Integer Division.    (line  45)
* mpz_tdiv_qr:                           Integer Division.    (line  43)
* mpz_tdiv_qr_ui:                        Integer Division.    (line  49)
* mpz_tdiv_r:                            Integer Division.    (line  42)
* mpz_tdiv_r_2exp:                       Integer Division.    (line  53)
* mpz_tdiv_r_ui:                         Integer Division.    (line  47)
* mpz_tdiv_ui:                           Integer Division.    (line  51)
* mpz_tstbit:                            Integer Logic and Bit Fiddling.
                                                              (line  60)
* mpz_ui_kronecker:                      Number Theoretic Functions.
                                                              (line  78)
* mpz_ui_pow_ui:                         Integer Exponentiation.
                                                              (line  33)
* mpz_ui_sub:                            Integer Arithmetic.  (line  16)
* mpz_urandomb:                          Integer Random Numbers.
                                                              (line  14)
* mpz_urandomm:                          Integer Random Numbers.
                                                              (line  23)
* mpz_xor:                               Integer Logic and Bit Fiddling.
                                                              (line  17)
* msqrt:                                 BSD Compatible Functions.
                                                              (line  63)
* msub:                                  BSD Compatible Functions.
                                                              (line  46)
* mtox:                                  BSD Compatible Functions.
                                                              (line  98)
* mult:                                  BSD Compatible Functions.
                                                              (line  49)
* operator%:                             C++ Interface Integers.
                                                              (line  30)
* operator/:                             C++ Interface Integers.
                                                              (line  29)
* operator<<:                            C++ Formatted Output.
                                                              (line  20)
* operator>> <1>:                        C++ Formatted Input. (line  11)
* operator>>:                            C++ Interface Rationals.
                                                              (line  77)
* pow:                                   BSD Compatible Functions.
                                                              (line  71)
* rpow:                                  BSD Compatible Functions.
                                                              (line  79)
* sdiv:                                  BSD Compatible Functions.
                                                              (line  55)
* sgn <1>:                               C++ Interface Rationals.
                                                              (line  50)
* sgn <2>:                               C++ Interface Integers.
                                                              (line  57)
* sgn:                                   C++ Interface Floats.
                                                              (line  89)
* sqrt <1>:                              C++ Interface Integers.
                                                              (line  58)
* sqrt:                                  C++ Interface Floats.
                                                              (line  90)
* trunc:                                 C++ Interface Floats.
                                                              (line  91)
* xtom:                                  BSD Compatible Functions.
                                                              (line  34)


                                                                                                                                                                                                                                                                                                                                                                                                                             This is mpfr.info, produced by makeinfo version 4.12 from mpfr.texi.

This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 3.0.0.

   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free
Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License, Version
1.2 or any later version published by the Free Software Foundation;
with no Invariant Sections, with no Front-Cover Texts, and with no
Back-Cover Texts.  A copy of the license is included in *note GNU Free
Documentation License::.

INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* mpfr: (mpfr).                 Multiple Precision Floating-Point Reliable Library.
END-INFO-DIR-ENTRY


File: mpfr.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

GNU MPFR
********

   This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 3.0.0.

   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free
Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License, Version
1.2 or any later version published by the Free Software Foundation;
with no Invariant Sections, with no Front-Cover Texts, and with no
Back-Cover Texts.  A copy of the license is included in *note GNU Free
Documentation License::.


* Menu:

* Copying::                     MPFR Copying Conditions (LGPL).
* Introduction to MPFR::        Brief introduction to GNU MPFR.
* Installing MPFR::             How to configure and compile the MPFR library.
* Reporting Bugs::              How to usefully report bugs.
* MPFR Basics::                 What every MPFR user should now.
* MPFR Interface::              MPFR functions and macros.
* API Compatibility::           API compatibility with previous MPFR versions.
* Contributors::
* References::
* GNU Free Documentation License::
* Concept Index::
* Function Index::


File: mpfr.info,  Node: Copying,  Next: Introduction to MPFR,  Prev: Top,  Up: Top

MPFR Copying Conditions
***********************

The GNU MPFR library (or MPFR for short) is "free"; this means that
everyone is free to use it and free to redistribute it on a free basis.
The library is not in the public domain; it is copyrighted and there
are restrictions on its distribution, but these restrictions are
designed to permit everything that a good cooperating citizen would
want to do.  What is not allowed is to try to prevent others from
further sharing any version of this library that they might get from
you.

   Specifically, we want to make sure that you have the right to give
away copies of the library, that you receive source code or else can
get it if you want it, that you can change this library or use pieces
of it in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the GNU MPFR library, you must give the recipients all the
rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for the GNU MPFR library.  If it is
modified by someone else and passed on, we want their recipients to
know that what they have is not what we distributed, so that any
problems introduced by others will not reflect on our reputation.

   The precise conditions of the license for the GNU MPFR library are
found in the Lesser General Public License that accompanies the source
code.  See the file COPYING.LESSER.


File: mpfr.info,  Node: Introduction to MPFR,  Next: Installing MPFR,  Prev: Copying,  Up: Top

1 Introduction to MPFR
**********************

MPFR is a portable library written in C for arbitrary precision
arithmetic on floating-point numbers. It is based on the GNU MP library.
It aims to provide a class of floating-point numbers with precise
semantics. The main characteristics of MPFR, which make it differ from
most arbitrary precision floating-point software tools, are:

   * the MPFR code is portable, i.e., the result of any operation does
     not depend on the machine word size `mp_bits_per_limb' (64 on most
     current processors);

   * the precision in bits can be set _exactly_ to any valid value for
     each variable (including very small precision);

   * MPFR provides the four rounding modes from the IEEE 754-1985
     standard, plus away-from-zero, as well as for basic operations as
     for other mathematical functions.

   In particular, with a precision of 53 bits, MPFR is able to exactly
reproduce all computations with double-precision machine floating-point
numbers (e.g., `double' type in C, with a C implementation that
rigorously follows Annex F of the ISO C99 standard and `FP_CONTRACT'
pragma set to `OFF') on the four arithmetic operations and the square
root, except the default exponent range is much wider and subnormal
numbers are not implemented (but can be emulated).

   This version of MPFR is released under the GNU Lesser General Public
License, version 3 or any later version.  It is permitted to link MPFR
to most non-free programs, as long as when distributing them the MPFR
source code and a means to re-link with a modified MPFR library is
provided.

1.1 How to Use This Manual
==========================

Everyone should read *note MPFR Basics::.  If you need to install the
library yourself, you need to read *note Installing MPFR::, too.  To
use the library you will need to refer to *note MPFR Interface::.

   The rest of the manual can be used for later reference, although it
is probably a good idea to glance through it.


File: mpfr.info,  Node: Installing MPFR,  Next: Reporting Bugs,  Prev: Introduction to MPFR,  Up: Top

2 Installing MPFR
*****************

The MPFR library is already installed on some GNU/Linux distributions,
but the development files necessary to the compilation such as `mpfr.h'
are not always present. To check that MPFR is fully installed on your
computer, you can check the presence of the file `mpfr.h' in
`/usr/include', or try to compile a small program having `#include
<mpfr.h>' (since `mpfr.h' may be installed somewhere else). For
instance, you can try to compile:

     #include <stdio.h>
     #include <mpfr.h>
     int main (void)
     {
       printf ("MPFR library: %-12s\nMPFR header:  %s (based on %d.%d.%d)\n",
               mpfr_get_version (), MPFR_VERSION_STRING, MPFR_VERSION_MAJOR,
               MPFR_VERSION_MINOR, MPFR_VERSION_PATCHLEVEL);
       return 0;
     }

with

     cc -o version version.c -lmpfr -lgmp

and if you get errors whose first line looks like

     version.c:2:19: error: mpfr.h: No such file or directory

then MPFR is probably not installed. Running this program will give you
the MPFR version.

   If MPFR is not installed on your computer, or if you want to install
a different version, please follow the steps below.

2.1 How to Install
==================

Here are the steps needed to install the library on Unix systems (more
details are provided in the `INSTALL' file):

  1. To build MPFR, you first have to install GNU MP (version 4.1 or
     higher) on your computer.  You need a C compiler, preferably GCC,
     but any reasonable compiler should work.  And you need the
     standard Unix `make' command, plus some other standard Unix
     utility commands.

     Then, in the MPFR build directory, type the following commands.

  2. `./configure'

     This will prepare the build and setup the options according to
     your system.  You can give options to specify the install
     directories (instead of the default `/usr/local'), threading
     support, and so on. See the `INSTALL' file and/or the output of
     `./configure --help' for more information, in particular if you
     get error messages.

  3. `make'

     This will compile MPFR, and create a library archive file
     `libmpfr.a'.  On most platforms, a dynamic library will be
     produced too.

  4. `make check'

     This will make sure MPFR was built correctly.  If you get error
     messages, please report this to `mpfr@loria.fr'.  (*Note Reporting
     Bugs::, for information on what to include in useful bug reports.)

  5. `make install'

     This will copy the files `mpfr.h' and `mpf2mpfr.h' to the directory
     `/usr/local/include', the library files (`libmpfr.a' and possibly
     others) to the directory `/usr/local/lib', the file `mpfr.info' to
     the directory `/usr/local/share/info', and some other documentation
     files to the directory `/usr/local/share/doc/mpfr' (or if you
     passed the `--prefix' option to `configure', using the prefix
     directory given as argument to `--prefix' instead of `/usr/local').

2.2 Other `make' Targets
========================

There are some other useful make targets:

   * `mpfr.info' or `info'

     Create or update an info version of the manual, in `mpfr.info'.

     This file is already provided in the MPFR archives.

   * `mpfr.pdf' or `pdf'

     Create a PDF version of the manual, in `mpfr.pdf'.

   * `mpfr.dvi' or `dvi'

     Create a DVI version of the manual, in `mpfr.dvi'.

   * `mpfr.ps' or `ps'

     Create a Postscript version of the manual, in `mpfr.ps'.

   * `mpfr.html' or `html'

     Create a HTML version of the manual, in several pages in the
     directory `mpfr.html'; if you want only one output HTML file, then
     type `makeinfo --html --no-split mpfr.texi' instead.

   * `clean'

     Delete all object files and archive files, but not the
     configuration files.

   * `distclean'

     Delete all generated files not included in the distribution.

   * `uninstall'

     Delete all files copied by `make install'.

2.3 Build Problems
==================

In case of problem, please read the `INSTALL' file carefully before
reporting a bug, in particular section "In case of problem".  Some
problems are due to bad configuration on the user side (not specific to
MPFR). Problems are also mentioned in the FAQ
`http://www.mpfr.org/faq.html'.

   Please report problems to `mpfr@loria.fr'.  *Note Reporting Bugs::.
Some bug fixes are available on the MPFR 3.0.0 web page
`http://www.mpfr.org/mpfr-3.0.0/'.

2.4 Getting the Latest Version of MPFR
======================================

The latest version of MPFR is available from
`ftp://ftp.gnu.org/gnu/mpfr/' or `http://www.mpfr.org/'.


File: mpfr.info,  Node: Reporting Bugs,  Next: MPFR Basics,  Prev: Installing MPFR,  Up: Top

3 Reporting Bugs
****************

If you think you have found a bug in the MPFR library, first have a look
on the MPFR 3.0.0 web page `http://www.mpfr.org/mpfr-3.0.0/' and the
FAQ `http://www.mpfr.org/faq.html': perhaps this bug is already known,
in which case you may find there a workaround for it.  You might also
look in the archives of the MPFR mailing-list:
`http://websympa.loria.fr/wwsympa/arc/mpfr'.  Otherwise, please
investigate and report it.  We have made this library available to you,
and it is not to ask too much from you, to ask you to report the bugs
that you find.

   There are a few things you should think about when you put your bug
report together.

   You have to send us a test case that makes it possible for us to
reproduce the bug, i.e., a small self-content program, using no other
library than MPFR.  Include instructions on how to run the test case.

   You also have to explain what is wrong; if you get a crash, or if
the results you get are incorrect and in that case, in what way.

   Please include compiler version information in your bug report. This
can be extracted using `cc -V' on some machines, or, if you're using
GCC, `gcc -v'. Also, include the output from `uname -a' and the MPFR
version (the GMP version may be useful too).

   If your bug report is good, we will do our best to help you to get a
corrected version of the library; if the bug report is poo÷  ◊  ÿ  Ÿ  ⁄  €  ‹  ›  ﬁ  ﬂ  ‡  ·  ‚  „  ‰  Â  Ê  Á  Ë  È  Í  Î  Ï  Ì  Ó  Ô    Ò  Ú  Û  Ù  ı  ˆ  ˜  ¯  ˘  ˙  ˚  ¸  ˝  ˛  ˇ                     	  
                                               !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~    Ä  Å  Ç  É  Ñ  Ö  Ü  á  à  â  ä  ã  å  ç  é  è  ê                                                                                                                                                                                                                                                                                      r, we will
not do anything about it (aside of chiding you to send better bug
reports).

   Send your bug report to: `mpfr@loria.fr'.

   If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please send a note
to the same address.


File: mpfr.info,  Node: MPFR Basics,  Next: MPFR Interface,  Prev: Reporting Bugs,  Up: Top

4 MPFR Basics
*************

4.1 Headers and Libraries
=========================

All declarations needed to use MPFR are collected in the include file
`mpfr.h'.  It is designed to work with both C and C++ compilers.  You
should include that file in any program using the MPFR library:

     #include <mpfr.h>

   Note however that prototypes for MPFR functions with `FILE *'
parameters are provided only if `<stdio.h>' is included too (before
`mpfr.h'):

     #include <stdio.h>
     #include <mpfr.h>

   Likewise `<stdarg.h>' (or `<varargs.h>') is required for prototypes
with `va_list' parameters, such as `mpfr_vprintf'.

   And for any functions using `intmax_t', you must include
`<stdint.h>' or `<inttypes.h>' before `mpfr.h', to allow `mpfr.h' to
define prototypes for these functions. Moreover, users of C++ compilers
under some platforms may need to define `MPFR_USE_INTMAX_T' (and should
do it for portability) before `mpfr.h' has been included; of course, it
is possible to do that on the command line, e.g., with
`-DMPFR_USE_INTMAX_T'.

   Note: If `mpfr.h' and/or `gmp.h' (used by `mpfr.h') are included
several times (possibly from another header file), the aforementioned
standard headers should be included *before* the first inclusion of
`mpfr.h' or `gmp.h'. For the time being, this problem is not avoidable
in MPFR without a change in GMP.

   You can avoid the use of MPFR macros encapsulating functions by
defining the `MPFR_USE_NO_MACRO' macro before `mpfr.h' is included.  In
general this should not be necessary, but this can be useful when
debugging user code: with some macros, the compiler may emit spurious
warnings with some warning options, and macros can prevent some
prototype checking.

   All programs using MPFR must link against both `libmpfr' and
`libgmp' libraries.  On a typical Unix-like system this can be done
with `-lmpfr -lgmp' (in that order), for example:

     gcc myprogram.c -lmpfr -lgmp

   MPFR is built using Libtool and an application can use that to link
if desired, *note GNU Libtool: (libtool.info)Top.

   If MPFR has been installed to a non-standard location, then it may be
necessary to set up environment variables such as `C_INCLUDE_PATH' and
`LIBRARY_PATH', or use `-I' and `-L' compiler options, in order to
point to the right directories. For a shared library, it may also be
necessary to set up some sort of run-time library path (e.g.,
`LD_LIBRARY_PATH') on some systems. Please read the `INSTALL' file for
additional information.

4.2 Nomenclature and Types
==========================

A "floating-point number", or "float" for short, is an arbitrary
precision significand (also called mantissa) with a limited precision
exponent. The C data type for such objects is `mpfr_t' (internally
defined as a one-element array of a structure, and `mpfr_ptr' is the C
data type representing a pointer to this structure). A floating-point
number can have three special values: Not-a-Number (NaN) or plus or
minus Infinity. NaN represents an uninitialized object, the result of
an invalid operation (like 0 divided by 0), or a value that cannot be
determined (like +Infinity minus +Infinity). Moreover, like in the IEEE
754 standard, zero is signed, i.e., there are both +0 and -0; the
behavior is the same as in the IEEE 754 standard and it is generalized
to the other functions supported by MPFR. Unless documented otherwise,
the sign bit of a NaN is unspecified.

The "precision" is the number of bits used to represent the significand
of a floating-point number; the corresponding C data type is
`mpfr_prec_t'.  The precision can be any integer between
`MPFR_PREC_MIN' and `MPFR_PREC_MAX'. In the current implementation,
`MPFR_PREC_MIN' is equal to 2.

   Warning! MPFR needs to increase the precision internally, in order to
provide accurate results (and in particular, correct rounding). Do not
attempt to set the precision to any value near `MPFR_PREC_MAX',
otherwise MPFR will abort due to an assertion failure. Moreover, you
may reach some memory limit on your platform, in which case the program
may abort, crash or have undefined behavior (depending on your C
implementation).

The "rounding mode" specifies the way to round the result of a
floating-point operation, in case the exact result can not be
represented exactly in the destination significand; the corresponding C
data type is `mpfr_rnd_t'.

4.3 MPFR Variable Conventions
=============================

Before you can assign to an MPFR variable, you need to initialize it by
calling one of the special initialization functions.  When you're done
with a variable, you need to clear it out, using one of the functions
for that purpose.  A variable should only be initialized once, or at
least cleared out between each initialization.  After a variable has
been initialized, it may be assigned to any number of times.  For
efficiency reasons, avoid to initialize and clear out a variable in
loops.  Instead, initialize it before entering the loop, and clear it
out after the loop has exited.  You do not need to be concerned about
allocating additional space for MPFR variables, since any variable has
a significand of fixed size.  Hence unless you change its precision, or
clear and reinitialize it, a floating-point variable will have the same
allocated space during all its life.

   As a general rule, all MPFR functions expect output arguments before
input arguments.  This notation is based on an analogy with the
assignment operator.  MPFR allows you to use the same variable for both
input and output in the same expression.  For example, the main
function for floating-point multiplication, `mpfr_mul', can be used
like this: `mpfr_mul (x, x, x, rnd)'.  This computes the square of X
with rounding mode `rnd' and puts the result back in X.

4.4 Rounding Modes
==================

The following five rounding modes are supported:

   * `MPFR_RNDN': round to nearest (roundTiesToEven in IEEE 754-2008),

   * `MPFR_RNDZ': round toward zero (roundTowardZero in IEEE 754-2008),

   * `MPFR_RNDU': round toward plus infinity (roundTowardPositive in
     IEEE 754-2008),

   * `MPFR_RNDD': round toward minus infinity (roundTowardNegative in
     IEEE 754-2008),

   * `MPFR_RNDA': round away from zero (experimental).

   The `round to nearest' mode works as in the IEEE 754 standard: in
case the number to be rounded lies exactly in the middle of two
representable numbers, it is rounded to the one with the least
significant bit set to zero.  For example, the number 2.5, which is
represented by (10.1) in binary, is rounded to (10.0)=2 with a
precision of two bits, and not to (11.0)=3.  This rule avoids the
"drift" phenomenon mentioned by Knuth in volume 2 of The Art of
Computer Programming (Section 4.2.2).

   Most MPFR functions take as first argument the destination variable,
as second and following arguments the input variables, as last argument
a rounding mode, and have a return value of type `int', called the
"ternary value". The value stored in the destination variable is
correctly rounded, i.e., MPFR behaves as if it computed the result with
an infinite precision, then rounded it to the precision of this
variable.  The input variables are regarded as exact (in particular,
their precision does not affect the result).

   As a consequence, in case of a non-zero real rounded result, the
error on the result is less or equal to 1/2 ulp (unit in the last
place) of that result in the rounding to nearest mode, and less than 1
ulp of that result in the directed rounding modes (a ulp is the weight
of the least significant represented bit of the result after rounding).

   Unless documented otherwise, functions returning an `int' return a
ternary value.  If the ternary value is zero, it means that the value
stored in the destination variable is the exact result of the
corresponding mathematical function. If the ternary value is positive
(resp. negative), it means the value stored in the destination variable
is greater (resp. lower) than the exact result. For example with the
`MPFR_RNDU' rounding mode, the ternary value is usually positive,
except when the result is exact, in which case it is zero. In the case
of an infinite result, it is considered as inexact when it was obtained
by overflow, and exact otherwise. A NaN result (Not-a-Number) always
corresponds to an exact return value.  The opposite of a returned
ternary value is guaranteed to be representable in an `int'.

   Unless documented otherwise, functions returning as result the value
`1' (or any other value specified in this manual) for special cases
(like `acos(0)') yield an overflow or an underflow if that value is not
representable in the current exponent range.

4.5 Floating-Point Values on Special Numbers
============================================

This section specifies the floating-point values (of type `mpfr_t')
returned by MPFR functions (where by "returned" we mean here the
modified value of the destination object, which should not be mixed
with the ternary return value of type `int' of those functions).  For
functions returning several values (like `mpfr_sin_cos'), the rules
apply to each result separately.

   Functions can have one or several input arguments. An input point is
a mapping from these input arguments to the set of the MPFR numbers.
When none of its components are NaN, an input point can also be seen as
a tuple in the extended real numbers (the set of the real numbers with
both infinities).

   When the input point is in the domain of the mathematical function,
the result is rounded as described in Section "Rounding Modes" (but see
below for the specification of the sign of an exact zero). Otherwise
the general rules from this section apply unless stated otherwise in
the description of the MPFR function (*note MPFR Interface::).

   When the input point is not in the domain of the mathematical
function but is in its closure in the extended real numbers and the
function can be extended by continuity, the result is the obtained
limit.  Examples: `mpfr_hypot' on (+Inf,0) gives +Inf. But `mpfr_pow'
cannot be defined on (1,+Inf) using this rule, as one can find
sequences (X_N,Y_N) such that X_N goes to 1, Y_N goes to +Inf and X_N
to the Y_N goes to any positive value when N goes to the infinity.

   When the input point is in the closure of the domain of the
mathematical function and an input argument is +0 (resp. -0), one
considers the limit when the corresponding argument approaches 0 from
above (resp. below). If the limit is not defined (e.g., `mpfr_log' on
-0), the behavior is specified in the description of the MPFR function.

   When the result is equal to 0, its sign is determined by considering
the limit as if the input point were not in the domain: If one
approaches 0 from above (resp. below), the result is +0 (resp. -0); for
example, `mpfr_sin' on +0 gives +0.  In the other cases, the sign is
specified in the description of the MPFR function; for example
`mpfr_max' on -0 and +0 gives +0.

   When the input point is not in the closure of the domain of the
function, the result is NaN. Example: `mpfr_sqrt' on -17 gives NaN.

   When an input argument is NaN, the result is NaN, possibly except
when a partial function is constant on the finite floating-point
numbers; such a case is always explicitly specified in *note MPFR
Interface::.  Example: `mpfr_hypot' on (NaN,0) gives NaN, but
`mpfr_hypot' on (NaN,+Inf) gives +Inf (as specified in *note Special
Functions::), since for any finite input X, `mpfr_hypot' on (X,+Inf)
gives +Inf.

4.6 Exceptions
==============

MPFR supports 5 exception types:

   * Underflow: An underflow occurs when the exact result of a function
     is a non-zero real number and the result obtained after the
     rounding, assuming an unbounded exponent range (for the rounding),
     has an exponent smaller than the minimum value of the current
     exponent range. (In the round-to-nearest mode, the halfway case is
     rounded toward zero.)

     Note: This is not the single possible definition of the underflow.
     MPFR chooses to consider the underflow _after_ rounding. The
     underflow before rounding can also be defined. For instance,
     consider a function that has the exact result 7 multiplied by two
     to the power E-4, where E is the smallest exponent (for a
     significand between 1/2 and 1), with a 2-bit target precision and
     rounding toward plus infinity.  The exact result has the exponent
     E-1. With the underflow before rounding, such a function call
     would yield an underflow, as E-1 is outside the current exponent
     range. However, MPFR first considers the rounded result assuming
     an unbounded exponent range.  The exact result cannot be
     represented exactly in precision 2, and here, it is rounded to 0.5
     times 2 to E, which is representable in the current exponent
     range. As a consequence, this will not yield an underflow in MPFR.

   * Overflow: An overflow occurs when the exact result of a function
     is a non-zero real number and the result obtained after the
     rounding, assuming an unbounded exponent range (for the rounding),
     has an exponent larger than the maximum value of the current
     exponent range. In the round-to-nearest mode, the result is
     infinite.  Note: unlike the underflow case, there is only one
     possible definition of overflow here.

   * NaN: A NaN exception occurs when the result of a function is NaN.

   * Inexact: An inexact exception occurs when the result of a function
     cannot be represented exactly and must be rounded.

   * Range error: A range exception occurs when a function that does
     not return a MPFR number (such as comparisons and conversions to
     an integer) has an invalid result (e.g., an argument is NaN in
     `mpfr_cmp', or a conversion to an integer cannot be represented in
     the target type).


   MPFR has a global flag for each exception, which can be cleared, set
or tested by functions described in *note Exception Related Functions::.

   Differences with the ISO C99 standard:

   * In C, only quiet NaNs are specified, and a NaN propagation does not
     raise an invalid exception. Unless explicitly stated otherwise,
     MPFR sets the NaN flag whenever a NaN is generated, even when a
     NaN is propagated (e.g., in NaN + NaN), as if all NaNs were
     signaling.

   * An invalid exception in C corresponds to either a NaN exception or
     a range error in MPFR.


4.7 Memory Handling
===================

MPFR functions may create caches, e.g., when computing constants such
as Pi, either because the user has called a function like
`mpfr_const_pi' directly or because such a function was called
internally by the MPFR library itself to compute some other function.

   At any time, the user can free the various caches with
`mpfr_free_cache'. It is strongly advised to do that before terminating
a thread, or before exiting when using tools like `valgrind' (to avoid
memory leaks being reported).

   MPFR internal data such as flags, the exponent range, the default
precision and rounding mode, and caches (i.e., data that are not
accessed via parameters) are either global (if MPFR has not been
compiled as thread safe) or per-thread (thread local storage).


File: mpfr.info,  Node: MPFR Interface,  Next: API Compatibility,  Prev: MPFR Basics,  Up: Top

5 MPFR Interface
****************

The floating-point functions expect arguments of type `mpfr_t'.

   The MPFR floating-point functions have an interface that is similar
to the GNU MP functions.  The function prefix for floating-point
operations is `mpfr_'.

   The user has to specify the precision of each variable.  A
computation that assigns a variable will take place with the precision
of the assigned variable; the cost of that computation should not
depend on the precision of variables used as input (on average).

   The semantics of a calculation in MPFR is specified as follows:
Compute the requested operation exactly (with "infinite accuracy"), and
round the result to the precision of the destination variable, with the
given rounding mode.  The MPFR floating-point functions are intended to
be a smooth extension of the IEEE 754 arithmetic. The results obtained
on a given computer are identical to those obtained on a computer with
a different word size, or with a different compiler or operating system.

   MPFR _does not keep track_ of the accuracy of a computation. This is
left to the user or to a higher layer (for example the MPFI library for
interval arithmetic).  As a consequence, if two variables are used to
store only a few significant bits, and their product is stored in a
variable with large precision, then MPFR will still compute the result
with full precision.

   The value of the standard C macro `errno' may be set to non-zero by
any MPFR function or macro, whether or not there is an error.

* Menu:

* Initialization Functions::
* Assignment Functions::
* Combined Initialization and Assignment Functions::
* Conversion Functions::
* Basic Arithmetic Functions::
* Comparison Functions::
* Special Functions::
* Input and Output Functions::
* Formatted Output Functions::
* Integer Related Functions::
* Rounding Related Functions::
* Miscellaneous Functions::
* Exception Related Functions::
* Compatibility with MPF::
* Custom Interface::
* Internals::


File: mpfr.info,  Node: Initialization Functions,  Next: Assignment Functions,  Prev: MPFR Interface,  Up: MPFR Interface

5.1 Initialization Functions
============================

An `mpfr_t' object must be initialized before storing the first value in
it.  The functions `mpfr_init' and `mpfr_init2' are used for that
purpose.

 -- Function: void mpfr_init2 (mpfr_t X, mpfr_prec_t PREC)
     Initialize X, set its precision to be *exactly* PREC bits and its
     value to NaN. (Warning: the corresponding MPF function initializes
     to zero instead.)

     Normally, a variable should be initialized once only or at least
     be cleared, using `mpfr_clear', between initializations.  To
     change the precision of a variable which has already been
     initialized, use `mpfr_set_prec'.  The precision PREC must be an
     integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX' (otherwise the
     behavior is undefined).

 -- Function: void mpfr_inits2 (mpfr_prec_t PREC, mpfr_t X, ...)
     Initialize all the `mpfr_t' variables of the given variable
     argument `va_list', set their precision to be *exactly* PREC bits
     and their value to NaN.  See `mpfr_init2' for more details.  The
     `va_list' is assumed to be composed only of type `mpfr_t' (or
     equivalently `mpfr_ptr').  It begins from X, and ends when it
     encounters a null pointer (whose type must also be `mpfr_ptr').

 -- Function: void mpfr_clear (mpfr_t X)
     Free the space occupied by the significand of X.  Make sure to
     call this function for all `mpfr_t' variables when you are done
     with them.

 -- Function: void mpfr_clears (mpfr_t X, ...)
     Free the space occupied by all the `mpfr_t' variables of the given
     `va_list'. See `mpfr_clear' for more details.  The `va_list' is
     assumed to be composed only of type `mpfr_t' (or equivalently
     `mpfr_ptr').  It begins from X, and ends when it encounters a null
     pointer (whose type must also be `mpfr_ptr').

   Here is an example of how to use multiple initialization functions
(since `NULL' is not necessarily defined in this context, we use
`(mpfr_ptr) 0' instead, but `(mpfr_ptr) NULL' is also correct).

     {
       mpfr_t x, y, z, t;
       mpfr_inits2 (256, x, y, z, t, (mpfr_ptr) 0);
       ...
       mpfr_clears (x, y, z, t, (mpfr_ptr) 0);
     }

 -- Function: void mpfr_init (mpfr_t X)
     Initialize X, set its precision to the default precision, and set
     its value to NaN.  The default precision can be changed by a call
     to `mpfr_set_default_prec'.

     Warning! In a given program, some other libraries might change the
     default precision and not restore it. Thus it is safer to use
     `mpfr_init2'.

 -- Function: void mpfr_inits (mpfr_t X, ...)
     Initialize all the `mpfr_t' variables of the given `va_list', set
     their precision to the default precision and their value to NaN.
     See `mpfr_init' for more details.  The `va_list' is assumed to be
     composed only of type `mpfr_t' (or equivalently `mpfr_ptr').  It
     begins from X, and ends when it encounters a null pointer (whose
     type must also be `mpfr_ptr').

     Warning! In a given program, some other libraries might change the
     default precision and not restore it. Thus it is safer to use
     `mpfr_inits2'.

 -- Macro: MPFR_DECL_INIT (NAME, PREC)
     This macro declares NAME as an automatic variable of type `mpfr_t',
     initializes it and sets its precision to be *exactly* PREC bits
     and its value to NaN. NAME must be a valid identifier.  You must
     use this macro in the declaration section.  This macro is much
     faster than using `mpfr_init2' but has some drawbacks:

        * You *must not* call `mpfr_clear' with variables created with
          this macro (the storage is allocated at the point of
          declaration and deallocated when the brace-level is exited).

        * You *cannot* change their precision.

        * You *should not* create variables with huge precision with
          this macro.

        * Your compiler must support `Non-Constant Initializers'
          (standard in C++ and ISO C99) and `Token Pasting' (standard
          in ISO C89). If PREC is not a constant expression, your
          compiler must support `variable-length automatic arrays'
          (standard in ISO C99). GCC 2.95.3 and above supports all
          these features.  If you compile your program with GCC in C89
          mode and with `-pedantic', you may want to define the
          `MPFR_USE_EXTENSION' macro to avoid warnings due to the
          `MPFR_DECL_INIT' implementation.

 -- Function: void mpfr_set_default_prec (mpfr_prec_t PREC)
     Set the default precision to be *exactly* PREC bits, where PREC
     can be any integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX'.
     The precision of a variable means the number of bits used to store
     its significand.  All subsequent calls to `mpfr_init' or
     `mpfr_inits' will use this precision, but previously initialized
     variables are unaffected.  The default precision is set to 53 bits
     initially.

 -- Function: mpfr_prec_t mpfr_get_default_prec (void)
     Return the current default MPFR precision in bits.

   Here is an example on how to initialize floating-point variables:

     {
       mpfr_t x, y;
       mpfr_init (x);                /* use default precision */
       mpfr_init2 (y, 256);          /* precision _exactly_ 256 bits */
       ...
       /* When the program is about to exit, do ... */
       mpfr_clear (x);
       mpfr_clear (y);
       mpfr_free_cache ();           /* free the cache for constants like pi */
     }

   The following functions are useful for changing the precision during
a calculation.  A typical use would be for adjusting the precision
gradually in iterative algorithms like Newton-Raphson, making the
computation precision closely match the actual accurate part of the
numbers.

 -- Function: void mpfr_set_prec (mpfr_t X, mpfr_prec_t PREC)
     Reset the precision of X to be *exactly* PREC bits, and set its
     value to NaN.  The previous value stored in X is lost. It is
     equivalent to a call to `mpfr_clear(x)' followed by a call to
     `mpfr_init2(x, prec)', but more efficient as no allocation is done
     in case the current allocated space for the significand of X is
     enough.  The precision PREC can be any integer between
     `MPFR_PREC_MIN' and `MPFR_PREC_MAX'.  In case you want to keep the
     previous value stored in X, use `mpfr_prec_round' instead.

 -- Function: mpfr_prec_t mpfr_get_prec (mpfr_t X)
     Return the precision of X, i.e., the number of bits used to store
     its significand.


File: mpfr.info,  Node: Assignment Functions,  Next: Combined Initialization and Assignment Functions,  Prev: Initialization Functions,  Up: MPFR Interface

5.2 Assignment Functions
========================

These functions assign new values to already initialized floats (*note
Initialization Functions::).

 -- Function: int mpfr_set (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_ui (mpfr_t ROP, unsigned long int OP,
          mpfr_rnd_t RND)
 -- Function: int mpfr_set_si (mpfr_t ROP, long int OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_uj (mpfr_t ROP, uintmax_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_sj (mpfr_t ROP, intmax_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_flt (mpfr_t ROP, float OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_d (mpfr_t ROP, double OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_ld (mpfr_t ROP, long double OP, mpfr_rnd_t
          RND)
 -- Function: int mpfr_set_decimal64 (mpfr_t ROP, _Decimal64 OP,
          mpfr_rnd_t RND)
 -- Function: int mpfr_set_z (mpfr_t ROP, mpz_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_q (mpfr_t ROP, mpq_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_set_f (mpfr_t ROP, mpf_t OP, mpfr_rnd_t RND)
     Set the value of ROP from OP, rounded toward the given direction
     RND.  Note that the input 0 is converted to +0 by `mpfr_set_ui',
     `mpfr_set_si', `mpfr_set_uj', `mpfr_set_sj', `mpfr_set_z',
     `mpfr_set_q' and `mpfr_set_f', regardless of the rounding mode.
     If the system does not support the IEEE 754 standard,
     `mpfr_set_flt', `mpfr_set_d', `mpfr_set_ld' and
     `mpfr_set_decimal64' might not preserve the signed zeros.  The
     `mpfr_set_decimal64' function is built only with the configure
     option `--enable-decimal-float', which also requires
     `--with-gmp-build', and when the compiler or system provides the
     `_Decimal64' data type (recent versions of GCC support this data
     type).  `mpfr_set_q' might fail if the numerator (or the
     denominator) can not be represented as a `mpfr_t'.

     Note: If you want to store a floating-point constant to a `mpfr_t',
     you should use `mpfr_set_str' (or one of the MPFR constant
     functions, such as `mpfr_const_pi' for Pi) instead of
     `mpfr_set_flt', `mpfr_set_d', `mpfr_set_ld' or
     `mpfr_set_decimal64'.  Otherwise the floating-point constant will
     be first converted into a reduced-precision (e.g., 53-bit) binary
     number before MPFR can work with it.

 -- Function: int mpfr_set_ui_2exp (mpfr_t ROP, unsigned long int OP,
          mpfr_exp_t E, mpfr_rnd_t RND)
 -- Function: int mpfr_set_si_2exp (mpfr_t ROP, long int OP, mpfr_exp_t
          E, mpfr_rnd_t RND)
 -- Function: int mpfr_set_uj_2exp (mpfr_t ROP, uintmax_t OP, intmax_t
          E, mpfr_rnd_t RND)
 -- Function: int mpfr_set_sj_2exp (mpfr_t ROP, intmax_t OP, intmax_t
          E, mpfr_rnd_t RND)
 -- Function: int mpfr_set_z_2exp (mpfr_t ROP, mpz_t OP, mpfr_exp_t E,
          mpfr_rnd_t RND)
     Set the value of ROP from OP multiplied by two to the power E,
     rounded toward the given direction RND.  Note that the input 0 is
     converted to +0.

 -- Function: int mpfr_set_str (mpfr_t ROP, const char *S, int BASE,
          mpfr_rnd_t RND)
     Set ROP to the value of the string S in base BASE, rounded in the
     direction RND.  See the documentation of `mpfr_strtofr' for a
     detailed description of the valid string formats.  Contrary to
     `mpfr_strtofr', `mpfr_set_str' requires the _whole_ string to
     represent a valid floating-point number.  This function returns 0
     if the entire string up to the final null character is a valid
     number in base BASE; otherwise it returns -1, and ROP may have
     changed.  Note: it is preferable to use `mpfr_set_str' if one
     wants to distinguish between an infinite ROP value coming from an
     infinite S or from an overflow.

 -- Function: int mpfr_strtofr (mpfr_t ROP, const char *NPTR, char
          **ENDPTR, int BASE, mpfr_rnd_t RND)
     Read a floating-point number from a string NPTR in base BASE,
     rounded in the direction RND; BASE must be either 0 (to detect the
     base, as described below) or a number from 2 to 62 (otherwise the
     behavior is undefined). If NPTR starts with valid data, the result
     is stored in ROP and `*ENDPTR' points to the character just after
     the valid data (if ENDPTR is not a null pointer); otherwise ROP is
     set to zero (for consistency with `strtod') and the value of NPTR
     is stored in the location referenced by ENDPTR (if ENDPTR is not a
     null pointer). The usual ternary value is returned.

     Parsing follows the standard C `strtod' function with some
     extensions.  After optional leading whitespace, one has a subject
     sequence consisting of an optional sign (`+' or `-'), and either
     numeric data or special data. The subject sequence is defined as
     the longest initial subsequence of the input string, starting with
     the first non-whitespace character, that is of the expected form.

     The form of numeric data is a non-empty sequence of significand
     digits with an optional decimal point, and an optional exponent
     consisting of an exponent prefix followed by an optional sign and
     a non-empty sequence of decimal digits. A significand digit is
     either a decimal digit or a Latin letter (62 possible characters),
     with `A' = 10, `B' = 11, ..., `Z' = 35; case is ignored in bases
     less or equal to 36, in bases larger than 36, `a' = 36, `b' = 37,
     ..., `z' = 61.  The value of a significand digit must be strictly
     less than the base.  The decimal point can be either the one
     defined by the current locale or the period (the first one is
     accepted for consistency with the C standard and the practice, the
     second one is accepted to allow the programmer to provide MPFR
     numbers from strings in a way that does not depend on the current
     locale).  The exponent prefix can be `e' or `E' for bases up to
     10, or `@' in any base; it indicates a multiplication by a power
     of the base. In bases 2 and 16, the exponent prefix can also be
     `p' or `P', in which case the exponent, called _binary exponent_,
     indicates a multiplication by a power of 2 instead of the base
     (there is a difference only for base 16); in base 16 for example
     `1p2' represents 4 whereas `1@2' represents 256. The value of an
     exponent is always written in base 10.

     If the argument BASE is 0, then the base is automatically detected
     as follows. If the significand starts with `0b' or `0B', base 2 is
     assumed. If the significand starts with `0x' or `0X', base 16 is
     assumed. Otherwise base 10 is assumed.

     Note: The exponent (if present) must contain at least a digit.
     Otherwise the possible exponent prefix and sign are not part of
     the number (which ends with the significand). Similarly, if `0b',
     `0B', `0x' or `0X' is not followed by a binary/hexadecimal digit,
     then the subject sequence stops at the character `0', thus 0 is
     read.

     Special data (for infinities and NaN) can be `@inf@' or
     `@nan@(n-char-sequence-opt)', and if BASE <= 16, it can also be
     `infinity', `inf', `nan' or `nan(n-char-sequence-opt)', all case
     insensitive.  A `n-char-sequence-opt' is a possibly empty string
     containing only digits, Latin letters and the underscore (0, 1, 2,
     ..., 9, a, b, ..., z, A, B, ..., Z, _). Note: one has an optional
     sign for all data, even NaN.  For example,
     `-@nAn@(This_Is_Not_17)' is a valid representation for NaN in base
     17.


 -- Function: void mpfr_set_nan (mpfr_t X)
 -- Function: void mpfr_set_inf (mpfr_t X, int SIGN)
 -- Function: void mpfr_set_zero (mpfr_t X, int SIGN)
     Set the variable X to NaN (Not-a-Number), infinity or zero
     respectively.  In `mpfr_set_inf' or `mpfr_set_zero', X is set to
     plus infinity or plus zero iff SIGN is nonnegative; in
     `mpfr_set_nan', the sign bit of the result is unspecified.

 -- Function: void mpfr_swap (mpfr_t X, mpfr_t Y)
     Swap the values X and Y efficiently. Warning: the precisions are
     exchanged too; in case the precisions are different, `mpfr_swap'
     is thus not equivalent to three `mpfr_set' calls using a third
     auxiliary variable.


File: mpfr.info,  Node: Combined Initialization and Assignment Functions,  Next: Conversion Functions,  Prev: Assignment Functions,  Up: MPFR Interface

5.3 Combined Initialization and Assignment Functions
====================================================

 -- Macro: int mpfr_init_set (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
 -- Macro: int mpfr_init_set_ui (mpfr_t ROP, unsigned long int OP,
          mpfr_rnd_t RND)
 -- Macro: int mpfr_init_set_si (mpfr_t ROP, long int OP, mpfr_rnd_t
          RND)
 -- Macro: int mpfr_init_set_d (mpfr_t ROP, double OP, mpfr_rnd_t RND)
 -- Macro: int mpfr_init_set_ld (mpfr_t ROP, long double OP, mpfr_rnd_t
          RND)
 -- Macro: int mpfr_init_set_z (mpfr_t ROP, mpz_t OP, mpfr_rnd_t RND)
 -- Macro: int mpfr_init_set_q (mpfr_t ROP, mpq_t OP, mpfr_rnd_t RND)
 -- Macro: int mpfr_init_set_f (mpfr_t ROP, mpf_t OP, mpfr_rnd_t RND)
     Initialize ROP and set its value from OP, rounded in the direction
     RND.  The precision of ROP will be taken from the active default
     precision, as set by `mpfr_set_default_prec'.

 -- Function: int mpfr_init_set_str (mpfr_t X, const char *S, int BASE,
          mpfr_rnd_t RND)
     Initialize X and set its value from the string S in base BASE,
     rounded in the direction RND.  See `mpfr_set_str'.


File: mpfr.info,  Node: Conversion Functions,  Next: Basic Arithmetic Functions,  Prev: Combined Initialization and Assignment Functions,  Up: MPFR Interface

5.4 Conversion Functions
========================

 -- Function: float mpfr_get_flt (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: double mpfr_get_d (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: long double mpfr_get_ld (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: _Decimal64 mpfr_get_decimal64 (mpfr_t OP, mpfr_rnd_t RND)
     Convert OP to a `float' (respectively `double', `long double' or
     `_Decimal64'), using the rounding mode RND.  If OP is NaN, some
     fixed NaN (either quiet or signaling) or the result of 0.0/0.0 is
     returned. If OP is ¬±Inf, an infinity of the same sign or the
     result of ¬±1.0/0.0 is returned. If OP is zero, these functions
     return a zero, trying to preserve its sign, if possible.  The
     `mpfr_get_decimal64' function is built only under some conditions:
     see the documentation of `mpfr_set_decimal64'.

 -- Function: long mpfr_get_si (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: unsigned long mpfr_get_ui (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: intmax_t mpfr_get_sj (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: uintmax_t mpfr_get_uj (mpfr_t OP, mpfr_rnd_t RND)
     Convert OP to a `long', an `unsigned long', an `intmax_t' or an
     `uintmax_t' (respectively) after rounding it with respect to RND.
     If OP is NaN, 0 is returned and the _erange_ flag is set.  If OP
     is too big for the return type, the function returns the maximum
     or the minimum of the corresponding C type, depending on the
     direction of the overflow; the _erange_ flag is set too.  See also
     `mpfr_fits_slong_p', `mpfr_fits_ulong_p', `mpfr_fits_intmax_p' and
     `mpfr_fits_uintmax_p'.

 -- Function: double mpfr_get_d_2exp (long *EXP, mpfr_t OP, mpfr_rnd_t
          RND)
 -- Function: long double mpfr_get_ld_2exp (long *EXP, mpfr_t OP,
          mpfr_rnd_t RND)
     Return D and set EXP (formally, the value pointed to by EXP) such
     that 0.5<=abs(D)<1 and D times 2 raised to EXP equals OP rounded
     to double (resp. long double) precision, using the given rounding
     mode.  If OP is zero, then a zero of the same sign (or an unsigned
     zero, if the implementation does not have signed zeros) is
     returned, and EXP is set to 0.  If OP is NaN or an infinity, then
     the corresponding double precision (resp. long-double precision)
     value is returned, and EXP is undefined.

 -- Function: mpfr_exp_t mpfr_get_z_2exp (mpz_t ROP, mpfr_t OP)
     Put the scaled significand of OP (regarded as an integer, with the
     precision of OP) into ROP, and return the exponent EXP (which may
     be outside the current exponent range) such that OP exactly equals
     ROP times 2 raised to the power EXP.  If OP is zero, the minimal
     exponent `emin' is returned.  If OP is NaN or an infinity, the
     _erange_ flag is set, ROP is set to 0, and the the minimal
     exponent `emin' is returned.  The returned exponent may be less
     than the minimal exponent `emin' of MPFR numbers in the current
     exponent range; in case the exponent is not representable in the
     `mpfr_exp_t' type, the _erange_ flag is set and the minimal value
     of the `mpfr_exp_t' type is returned.

 -- Function: int mpfr_get_z (mpz_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Convert OP to a `mpz_t', after rounding it with respect to RND. If
     OP is NaN or an infinity, the _erange_ flag is set, ROP is set to
     0, and 0 is returned.

 -- Function: int mpfr_get_f (mpf_t ROP, mpfr_t OP, mpfr_rnd_t RND)
     Convert OP to a `mpf_t', after rounding it with respect to RND.
     The _erange_ flag is set if OP is NaN or Inf, which do not exist in
     MPF.

 -- Function: char * mpfr_get_str (char *STR, mpfr_exp_t *EXPPTR, int
          B, size_t N, mpfr_t OP, mpfr_rnd_t RND)
     Convert OP to a string of digits in base B, with rounding in the
     direction RND, where N is either zero (see below) or the number of
     significant digits output in the string; in the latter case, N
     must be greater or equal to 2. The base may vary from 2 to 62.  If
     the input number is an ordinary number, the exponent is written
     through the pointer EXPPTR (for input 0, the current minimal
     exponent is written).

     The generated string is a fraction, with an implicit radix point
     immediately to the left of the first digit.  For example, the
     number -3.1416 would be returned as "-31416" in the string and 1
     written at EXPPTR.  If RND is to nearest, and OP is exactly in the
     middle of two consecutive possible outputs, the one with an even
     significand is chosen, where both significands are considered with
     the exponent of OP.  Note that for an odd base, this may not
     correspond to an even last digit: for example with 2 digits in
     base 7, (14) and a half is rounded to (15) which is 12 in decimal,
     (16) and a half is rounded to (20) which is 14 in decimal, and
     (26) and a half is rounded to (26) which is 20 in decimal.

     If N is zero, the number of digits of the significand is chosen
     large enough so that re-reading the printed value with the same
     precision, assuming both output and input use rounding to nearest,
     will recover the original value of OP.  More precisely, in most
     cases, the chosen precision of STR is the minimal precision m
     depending only on P = PREC(OP) and B that satisfies the above
     property, i.e., m = 1 + ceil(P*log(2)/log(B)), with P replaced by
     P-1 if B is a power of 2, but in some very rare cases, it might be
     m+1 (the smallest case for bases up to 62 is when P equals
     186564318007 for bases 7 and 49).

     If STR is a null pointer, space for the significand is allocated
     using the current allocation function, and a pointer to the string
     is returned.  To free the returned string, you must use
     `mpfr_free_str'.

     If STR is not a null pointer, it should point to a block of storage
     large enough for the significand, i.e., at least `max(N + 2, 7)'.
     The extra two bytes are for a possible minus sign, and for the
     terminating null character, and the value 7 accounts for `-@Inf@'
     plus the terminating null character.

     A pointer to the string is returned, unless there is an error, in
     which case a null pointer is returned.

 -- Function: void mpfr_free_str (char *STR)
     Free a string allocated by `mpfr_get_str' using the current
     unallocation function.  The block is assumed to be `strlen(STR)+1'
     bytes.  For more information about how it is done: *note Custom
     Allocation: (gmp.info)Custom Allocation.

 -- Function: int mpfr_fits_ulong_p (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_fits_slong_p (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_fits_uint_p (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_fits_sint_p (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_fits_ushort_p (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_fits_sshort_p (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_fits_uintmax_p (mpfr_t OP, mpfr_rnd_t RND)
 -- Function: int mpfr_fits_intmax_p (mpfr_t OP, mpfr_rnd_t RND)
     Return non-zero if OP would fit in the respective C data type,
     respectively `unsigned long', `long', `unsigned int', `int',
     `unsigned short', `short', `uintmax_t', `intmax_t', when rounded
     to an integer in the direction RND.


File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,  Prev: Conversion Functions,  Up: MPFR Interface

5.5 Basic Arithmetic Functions
==============================

 -- Function: int mpfr_add (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_add_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_add_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_add_d (mpfr_t ROP, mpfr_t OP1, double OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_add_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_add_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
          mpfr_rnd_t RND)
     Set ROP to OP1 + OP2 rounded in the direction RND. For types
     having no signed zero, it is considered unsigned (i.e., (+0) + 0 =
     (+0) and (-0) + 0 = (-0)).  The `mpfr_add_d' function assumes that
     the radix of the `double' type is a power of 2, with a precision
     at most that declared by the C implementation (macro
     `IEEE_DBL_MANT_DIG', and if not defined 53 bits).

 -- Function: int mpfr_sub (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
          mpfr_rnd_t RND)
 -- Function: int mpfr_ui_sub (mpfr_t ROP, unsigned long int OP1,
          mpfr_t OP2, mpfr_rnd_t RND)
 -- Function: int mpfr_sub_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
          int OP2, mpfr_rnd_t RND)
 -- 