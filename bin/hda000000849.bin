d the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Authors of MPFR (in chronological order of initial contribution):

Guillaume Hanrot        Main author
Fabrice Rouillier       Original version of mul_ui.c, gmp_op.c
Paul Zimmermann         Main author
Sylvie Boldo            Original version of agm.c and log.c
Emmanuel Jeandel        Original version of exp3.c, const_pi.c, sincos.c
Mathieu Dutour          asin.c, atan.c and gamma.c
Vincent LefÃ¨vre         Main author
David Daney             Hyperbolic and inverse hyperbolic functions, base-2
                        and base-10 exponential and logarithm, factorial
Patrick PÃ©lissier       Main author
Laurent Fousse          Original version of sum.c
Philippe ThÃ©veny        Main author
Sylvain Chevillard      Original version of ai.c

All authors are included in the MPFR mailing-list <mpfr@loria.fr>.
This is the preferred way to contact us. For further information, please
look at the MPFR web page <http://www.mpfr.org/>.
                                                                                        Copyright 1999, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
Contributed by the Arenaire and Cacao projects, INRIA.

This file is part of the GNU MPFR Library.

The GNU MPFR Library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

The GNU MPFR Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the GNU MPFR Library; see the file COPYING.LESSER.  If not, see
http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.

##############################################################################

Probably many bugs.

Known bugs:

* The overflow/underflow exceptions may be badly handled in some functions;
  specially when the intermediary internal results have exponent which
  exceeds the hardware limit (2^30 for a 32 bits CPU, and 2^62 for a 64 bits
  CPU) or the exact result is close to an overflow/underflow threshold.

* Under Linux/x86 with the traditional FPU, some functions do not work
  if the FPU rounding precision has been changed to single (this is a
  bad practice and should be useless, but one never knows what other
  software will do).

* Some functions do not use MPFR_SAVE_EXPO_* macros, thus do not behave
  correctly in a reduced exponent range.

* Function hypot gives incorrect result when on the one hand the difference
  between parameters' exponents is near 2*MPFR_EMAX_MAX and on the other hand
  the output precision or the precision of the parameter with greatest
  absolute value is greater than 2*MPFR_EMAX_MAX-4.

Potential bugs:

* Possible incorrect results due to internal underflow, which can lead to
  a huge loss of accuracy while the error analysis doesn't take that into
  account. If the underflow occurs at the last function call (just before
  the MPFR_CAN_ROUND), the result should be correct (or MPFR gets into an
  infinite loop). TODO: check the code and the error analysis.

* Possible integer overflows on some machines.

* Possible bugs with huge precisions (> 2^30).

* Possible bugs if the chosen exponent range does not allow to represent
  the range [1/16, 16].

* Possible infinite loop in some functions for particular cases: when
  the exact result is an exactly representable number or the middle of
  consecutive two such numbers. However for non-algebraic functions, it is
  believed that no such case exists, except the well-known cases like cos(0)=1,
  exp(0)=1, and so on, and the x^y function when y is an integer or y=1/2^k.

* The mpfr_set_ld function may be quite slow if the long double type has an
  exponent of more than 15 bits.

* mpfr_set_d may give wrong results on some non-IEEE architectures.

* Error analysis for some functions may be incorrect (out-of-date due
  to modifications in the code?).

* Possible use of non-portable feature (pre-C99) of the integer division
  with negative result.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
Contributed by the Arenaire and Cacao projects, INRIA.

This file is part of the GNU MPFR Library.

The GNU MPFR Library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

The GNU MPFR Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the GNU MPFR Library; see the file COPYING.LESSER.  If not, see
http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.

Table of contents:
1. Documentation
2. Installation
3. Changes in existing functions
4. New functions to implement
5. Efficiency
6. Miscellaneous
7. Portability

##############################################################################
1. Documentation
##############################################################################

- add a description of the algorithms used + proof of correctness

##############################################################################
2. Installation
##############################################################################

- if we want to distinguish GMP and MPIR, we can check at configure time
  the following symbols which are only defined in MPIR:

  #define __MPIR_VERSION 0
  #define __MPIR_VERSION_MINOR 9
  #define __MPIR_VERSION_PATCHLEVEL 0

  There is also a library symbol mpir_version, which should match VERSION, set
  by configure, for example 0.9.0.

##############################################################################
3. Changes in existing functions
##############################################################################

- many functions currently taking into account the precision of the *input*
  variable to set the initial working precison (acosh, asinh, cosh, ...).
  This is nonsense since the "average" working precision should only depend
  on the precision of the *output* variable (and maybe on the *value* of
  the input in case of cancellation).
  -> remove those dependencies from the input precision.

- mpfr_get_str should support base up to 62 too.

- mpfr_can_round:
   change the meaning of the 2nd argument (err). Currently the error is
   at most 2^(MPFR_EXP(b)-err), i.e. err is the relative shift wrt the
   most significant bit of the approximation. I propose that the error
   is now at most 2^err ulps of the approximation, i.e.
   2^(MPFR_EXP(b)-MPFR_PREC(b)+err).

- mpfr_set_q first tries to convert the numerator and the denominator
  to mpfr_t. But this convertion may fail even if the correctly rounded
  result is representable. New way to implement:
  Function q = a/b.  nq = PREC(q) na = PREC(a) nb = PREC(b)
    If na < nb
       a <- a*2^(nb-na)
    n <- na-nb+ (HIGH(a,nb) >= b)
    if (n >= nq)
       bb <- b*2^(n-nq)
       a  = q*bb+r     --> q has exactly n bits.
    else
       aa <- a*2^(nq-n)
       aa = q*b+r      --> q has exaclty n bits.
  If RNDN, takes nq+1 bits. (See also the new division function).


##############################################################################
4. New functions to implement
##############################################################################

- implement mpfr_z_sub, mpfr_q_sub, mpfr_z_div, mpfr_q_div?
- implement functions for random distributions, see for example
  http://websympa.loria.fr/wwsympa/arc/mpfr/2010-01/msg00034.html
  (suggested by Charles Karney <ckarney@Sarnoff.com>, 18 Jan 2010):
   * a Bernoulli distribution with prob p/q (exact)
   * a general discrete distribution (i with prob w[i]/sum(w[i]) (Walker
     algorithm, but make it exact)
   * a uniform distribution in (a,b)
   * exponential distribution (mean lambda) (von Neumann's method?)
   * normal distribution (mean m, s.d. sigma) (ratio method?)
- wanted for Magma [John Cannon <john@maths.usyd.edu.au>, Tue, 19 Apr 2005]:
  HypergeometricU(a,b,s) = 1/gamma(a)*int(exp(-su)*u^(a-1)*(1+u)^(b-a-1),
                                    u=0..infinity)
  JacobiThetaNullK
  PolylogP, PolylogD, PolylogDold: see http://arxiv.org/abs/math.CA/0702243
    and the references herein.
  JBessel(n, x) = BesselJ(n+1/2, x)
  IncompleteGamma [also wanted by <keith.briggs@bt.com> 4 Feb 2008: Gamma(a,x),
    gamma(a,x), P(a,x), Q(a,x); see A&S 6.5, ref. [Smith01] in algorithms.bib]
  KBessel, KBessel2 [2nd kind]
  JacobiTheta
  LogIntegral
  ExponentialIntegralE1
    E1(z) = int(exp(-t)/t, t=z..infinity), |arg z| < Pi
    mpfr_eint1: implement E1(x) for x > 0, and Ei(-x) for x < 0
    E1(NaN)  = NaN
    E1(+Inf) = +0
    E1(-Inf) = -Inf
    E1(+0)   = +Inf
    E1(-0)   = -Inf
  DawsonIntegral
  GammaD(x) = Gamma(x+1/2)
- functions defined in the LIA-2 standard
  + minimum and maximum (5.2.2): max, min, max_seq, min_seq, mmax_seq
    and mmin_seq (mpfr_min and mpfr_max correspond to mmin and mmax);
  + rounding_rest, floor_rest, ceiling_rest (5.2.4);
  + remr (5.2.5): x - round(x/y) y;
  + error functions from 5.2.7 (if useful in MPFR);
  + power1pm1 (5.3.6.7): (1 + x)^y - 1;
  + logbase (5.3.6.12): \log_x(y);
  + logbase1p1p (5.3.6.13): \log_{1+x}(1+y);
  + rad (5.3.9.1): x - round(x / (2 pi)) 2 pi = remr(x, 2 pi);
  + axis_rad (5.3.9.1) if useful in MPFR;
  + cycle (5.3.10.1): rad(2 pi x / u) u / (2 pi) = remr(x, u);
  + axis_cycle (5.3.10.1) if useful in MPFR;
  + sinu, cosu, tanu, cotu, secu, cscu, cossinu, arcsinu, arccosu,
    arctanu, arccotu, arcsecu, arccscu (5.3.10.{2..14}):
    sin(x 2 pi / u), etc.;
    [from which sinpi(x) = sin(Pi*x), ... are trivial to implement, with u=2.]
  + arcu (5.3.10.15): arctan2(y,x) u / (2 pi);
  + rad_to_cycle, cycle_to_rad, cycle_to_cycle (5.3.11.{1..3}).
- From GSL, missing special functions (if useful in MPFR):
  (cf http://www.gnu.org/software/gsl/manual/gsl-ref.html#Special-Functions)
  + The Airy functions Ai(x) and Bi(x) defined by the integral representations:
   * Ai(x) = (1/\pi) \int_0^\infty \cos((1/3) t^3 + xt) dt
   * Bi(x) = (1/\pi) \int_0^\infty (e^(-(1/3) t^3) + \sin((1/3) t^3 + xt)) dt
   * Derivatives of Airy Functions
  + The Bessel functions for n integer and n fractional:
   * Regular Modified Cylindrical Bessel Functions I_n
   * Irregular Modified Cylindrical Bessel Functions K_n
   * Regular Spherical Bessel Functions j_n: j_0(x) = \sin(x)/x,
     j_1(x)= (\sin(x)/x-\cos(x))/x & j_2(x)= ((3/x^2-1)\sin(x)-3\cos(x)/x)/x
     Note: the "spherical" Bessel functions are solutions of
     x^2 y'' + 2 x y' + [x^2 - n (n+1)] y = 0 and satisfy
     j_n(x) = sqrt(Pi/(2x)) J_{n+1/2}(x). They should not be mixed with the
     classical Bessel Functions, also noted j0, j1, jn, y0, y1, yn in C99
     and mpfr.
     Cf http://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions
   *Irregular Spherical Bessel Functions y_n: y_0(x) = -\cos(x)/x,
     y_1(x)= -(\cos(x)/x+\sin(x))/x &
     y_2(x)= (-3/x^3+1/x)\cos(x)-(3/x^2)\sin(x)
   * Regular Modified Spherical Bessel Functions i_n:
     i_l(x) = \sqrt{\pi/(2x)} I_{l+1/2}(x)
   * Irregular Modified Spherical Bessel Functions:
     k_l(x) = \sqrt{\pi/(2x)} K_{l+1/2}(x).
  + Clausen Function:
     Cl_2(x) = - \int_0^x dt \log(2 \sin(t/2))
     Cl_2(\theta) = \Im Li_2(\exp(i \theta)) (dilogarithm).
  + Dawson Function: \exp(-x^2) \int_0^x dt \exp(t^2).
  + Debye Functions: D_n(x) = n/x^n \int_0^x dt (t^n/(e^t - 1))
  + Elliptic Integrals:
   * Definition of Legendre Forms:
    F(\phi,k) = \int_0^\phi dt 1/\sqrt((1 - k^2 \sin^2(t)))
    E(\phi,k) = \int_0^\phi dt   \sqrt((1 - k^2 \sin^2(t)))
    P(\phi,k,n) = \int_0^\phi dt 1/((1 + n \sin^2(t))\sqrt(1 - k^2 \sin^2(t)))
   * Complete Legendre forms are denoted by
    K(k) = F(\pi/2, k)
    E(k) = E(\pi/2, k)
   * Definition of Carlson Forms
    RC(x,y) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1)
    RD(x,y,z) = 3/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-3/2)
    RF(x,y,z) = 1/2 \int_0^\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2)
    RJ(x,y,z,p) = 3/2 \int_0^\infty dt
                          (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2) (t+p)^(-1)
  + Elliptic Functions (Jacobi)
  + N-relative exponential:
     exprel_N(x) = N!/x^N (\exp(x) - \sum_{k=0}^{N-1} x^k/k!)
  + exponential integral:
     E_2(x) := \Re \int_1^\infty dt \exp(-xt)/t^2.
     Ei_3(x) = \int_0^x dt \exp(-t^3) for x >= 0.
     Ei(x) := - PV(\int_{-x}^\infty dt \exp(-t)/t)
  + Hyperbolic/Trigonometric Integrals
     Shi(x) = \int_0^x dt \sinh(t)/t
     Chi(x) := Re[ \gamma_E + \log(x) + \int_0^x dt (\cosh[t]-1)/t]
     Si(x) = \int_0^x dt \sin(t)/t
     Ci(x) = -\int_x^\infty dt \cos(t)/t for x > 0
     AtanInt(x) = \int_0^x dt \arctan(t)/t
     [ \gamma_E is the Euler constant ]
  + Fermi-Dirac Function:
     F_j(x)   := (1/r\Gamma(j+1)) \int_0^\infty dt (t^j / (\exp(t-x) + 1))
  + Pochhammer symbol (a)_x := \Gamma(a + x)/\Gamma(a) : see [Smith01] in
          algorithms.bib
    logarithm of the Pochhammer symbol
  + Gegenbauer Functions
  + Laguerre Functions
  + Eta Function: \eta(s) = (1-2^{1-s}) \zeta(s)
    Hurwitz zeta function: \zeta(s,q) = \sum_0^\infty (k+q)^{-s}.
  + Lambert W Functions, W(x) are defined to be solutions of the equation:
     W(x) \exp(W(x)) = x.
    This function has multiple branches for x < 0 (2 funcs W0(x) and Wm1(x))
  + Trigamma Function psi'(x).
    and Polygamma Function: psi^{(m)}(x) for m >= 0, x > 0.

- from gnumeric (www.gnome.org/projects/gnumeric/doc/function-reference.html):
  - beta
  - betaln
  - degrees
  - radians
  - sqrtpi

- mpfr_frexp(mpfr_t rop, mpfr_exp_t *n, mpfr_t op, mpfr_rnd_t rnd) suggested
  by Steve Kargl <sgk@troutmask.apl.washington.edu> Sun, 7 Aug 2005
- mpfr_inp_raw, mpfr_out_raw (cf mail "Serialization of mpfr_t" from Alexey
  and answer from Granlund on mpfr list, May 2007)
- [maybe useful for SAGE] implement companion frac_* functions to the rint_*
  functions. For example mpfr_frac_floor(x) = x - floor(x). (The current
  mpfr_frac function corresponds to mpfr_rint_trunc.)
- scaled erfc (http://websympa.loria.fr/wwsympa/arc/mpfr/2009-05/msg00054.html)
- asec, acsc, acot, asech, acsch and acoth (mail from Björn Terelius on mpfr
  list, 18 June 2009)

##############################################################################
5. Efficiency
##############################################################################

- compute exp by using the series for cosh or sinh, which has half the terms
  (see Exercise 4.11 from Modern Computer Arithmetic, version 0.3)
  The same method can be used for log, using the series for atanh, i.e.,
  atanh(x) = 1/2*log((1+x)/(1-x)).
- improve mpfr_gamma (see http://code.google.com/p/fastfunlib/). A possible
  idea is to implement a fast algorithm for the argument reconstruction
  gamma(x+k). One could also use the series for 1/gamma(x), see for example
  http://dlmf.nist.gov/5/7/ or formula (36) from
  http://mathworld.wolfram.com/GammaFunction.html
- fix regression with mpfr_mpz_root (from Keith Briggs, 5 July 2006), for
   example on 3Ghz P4 with gmp-4.2, x=12.345:
   prec=50000    k=2   k=3   k=10  k=100
   mpz_root      0.036 0.072 0.476 7.628
   mpfr_mpz_root 0.004 0.004 0.036 12.20
   See also mail from Carl Witty on mpfr list, 09 Oct 2007.
- implement Mulders algorithm for squaring and division
- for sparse input (say x=1 with 2 bits), mpfr_exp is not faster than for
        full precision when precision <= MPFR_EXP_THRESHOLD. The reason is
        that argument reduction kills sparsity. Maybe avoid argument reduction
        for sparse input?
- speed up const_euler for large precision [for x=1.1, prec=16610, it takes
        75% of the total time of eint(x)!]
- speed up mpfr_atan for large arguments (to speed up mpc_log)
        [from Mark Watkins on Fri, 18 Mar 2005]
  Also mpfr_atan(x) seems slower (by a factor of 2) for x near from 1.
  Example on a Athlon for 10^5 bits: x=1.1 takes 3s, whereas 2.1 takes 1.8s.
  The current imple]Ô  ^Ô  _Ô  `Ô  aÔ  bÔ  cÔ  dÔ  eÔ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              mentation does not give monotonous timing for the following:
  mpfr_random (x); for (i = 0; i < k; i++) mpfr_atan (y, x, MPFR_RNDN);
  for precision 300 and k=1000, we get 1070ms, and 500ms only for p=400!
- improve mpfr_sin on values like ~pi (do not compute sin from cos, because
  of the cancellation). For instance, reduce the input modulo pi/2 in
  [-pi/4,pi/4], and define auxiliary functions for which the argument is
  assumed to be already reduced (so that the sin function can avoid
  unnecessary computations by calling the auxiliary cos function instead of
  the full cos function). This will require a native code for sin, for
  example using the reduction sin(3x)=3sin(x)-4sin(x)^3.
  See http://websympa.loria.fr/wwsympa/arc/mpfr/2007-08/msg00001.html and
  the following messages.
- improve generic.c to work for number of terms <> 2^k
- rewrite mpfr_greater_p... as native code.
- inline mpfr_neg? Problems with NAN flags:
   #define mpfr_neg(_d,_x,_r)                          \
    (__builtin_constant_p ((_d)==(_x)) && (_d)==(_x) ? \
     ((_d)->_mpfr_sign = -(_d)->_mpfr_sign, 0)       : \
      mpfr_neg ((_d), (_x), (_r)))  */

- mpf_t uses a scheme where the number of limbs actually present can
  be less than the selected precision, thereby allowing low precision
  values (for instance small integers) to be stored and manipulated in
  an mpf_t efficiently.

  Perhaps mpfr should get something similar, especially if looking to
  replace mpf with mpfr, though it'd be a major change.  Alternately
  perhaps those mpfr routines like mpfr_mul where optimizations are
  possible through stripping low zero bits or limbs could check for
  that (this would be less efficient but easier).

- try the idea of the paper "Reduced Cancellation in the Evaluation of Entire
  Functions and Applications to the Error Function" by W. Gawronski, J. Mueller
  and M. Reinhard, to be published in SIAM Journal on Numerical Analysis: to
  avoid cancellation in say erfc(x) for x large, they compute the Taylor
  expansion of erfc(x)*exp(x^2/2) instead (which has less cancellation),
  and then divide by exp(x^2/2) (which is simpler to compute).

- replace the *_THRESHOLD macros by global (TLS) variables that can be
  changed at run time (via a function, like other variables)? One benefit
  is that users could use a single MPFR binary on several machines (e.g.,
  a library provided by binary packages or shared via NFS) with different
  thresholds. On the default values, this would be a bit less efficient
  than the current code, but this isn't probably noticeable (this should
  be tested). Something like:
    long *mpfr_tune_get(void) to get the current values (the first value
      is the size of the array).
    int mpfr_tune_set(long *array) to set the tune values.
    int mpfr_tune_run(long level) to find the best values (the support
      for this feature is optional, this can also be done with an
      external function).

- better distinguish different processors (for example Opteron and Core 2)
  and use corresponding default tuning parameters (as in GMP). This could be
  done in configure.in to avoid hacking config.guess, for example define
  MPFR_HAVE_CORE2.
  Note (VL): the effect on cross-compilation (that can be a processor
  with the same architecture, e.g. compilation on a Core 2 for an
  Opteron) is not clear. The choice should be consistent with the
  build target (e.g. -march or -mtune value with gcc).
  Also choose better default values. For instance, the default value of
  MPFR_MUL_THRESHOLD is 40, while the best values that have been found
  are between 11 and 19 for 32 bits and between 4 and 10 for 64 bits!

- during the Many Digits competition, we noticed that (our implantation of)
  Mulders short product was slower than a full product for large sizes.
  This should be precisely analyzed and fixed if needed.

##############################################################################
6. Miscellaneous
##############################################################################

- Once the double inclusion of mpfr.h is fully supported, add tstdint
  to check_PROGRAMS in the tests/Makefile.am file.

- [suggested by Tobias Burnus <burnus(at)net-b.de> and
   Asher Langton <langton(at)gcc.gnu.org>, Wed, 01 Aug 2007]
  support quiet and signaling NaNs in mpfr:
  * functions to set/test a quiet/signaling NaN: mpfr_set_snan, mpfr_snan_p,
    mpfr_set_qnan, mpfr_qnan_p
  * correctly convert to/from double (if encoding of s/qNaN is fixed in 754R)

- check again coverage: on July 27, Patrick Pelissier reports that the
  following files are not tested at 100%: add1.c, atan.c, atan2.c,
  cache.c, cmp2.c, const_catalan.c, const_euler.c, const_log2.c, cos.c,
  gen_inverse.h, div_ui.c, eint.c, exp3.c, exp_2.c, expm1.c, fma.c, fms.c,
  lngamma.c, gamma.c, get_d.c, get_f.c, get_ld.c, get_str.c, get_z.c,
  inp_str.c, jn.c, jyn_asympt.c, lngamma.c, mpfr-gmp.c, mul.c, mul_ui.c,
  mulders.c, out_str.c, pow.c, print_raw.c, rint.c, root.c, round_near_x.c,
  round_raw_generic.c, set_d.c, set_ld.c, set_q.c, set_uj.c, set_z.c, sin.c,
  sin_cos.c, sinh.c, sqr.c, stack_interface.c, sub1.c, sub1sp.c, subnormal.c,
  uceil_exp2.c, uceil_log2.c, ui_pow_ui.c, urandomb.c, yn.c, zeta.c, zeta_ui.c.

- check the constants mpfr_set_emin (-16382-63) and mpfr_set_emax (16383) in
  get_ld.c and the other constants, and provide a testcase for large and
  small numbers.

- from Kevin Ryde <user42@zip.com.au>:
   Also for pi.c, a pre-calculated compiled-in pi to a few thousand
   digits would be good value I think.  After all, say 10000 bits using
   1250 bytes would still be small compared to the code size!
   Store pi in round to zero mode (to recover other modes).

- add a new rounding mode: round to nearest, with ties away from zero
  (this is roundTiesToAway in 754-2008, could be used by mpfr_round)
- add a new roundind mode: round to odd. If the result is not exactly
        representable, then round to the odd mantissa. This rounding
        has the nice property that for k > 1, if:
        y = round(x, p+k, TO_ODD)
        z = round(y, p, TO_NEAREST_EVEN), then
        z = round(x, p, TO_NEAREST_EVEN)
  so it avoids the double-rounding problem.

- add tests of the ternary value for constants

- When doing Extensive Check (--enable-assert=full), since all the
  functions use a similar use of MACROS (ZivLoop, ROUND_P), it should
  be possible to do such a scheme:
    For the first call to ROUND_P when we can round.
    Mark it as such and save the approximated rounding value in
    a temporary variable.
    Then after, if the mark is set, check if:
      - we still can round.
      - The rounded value is the same.
  It should be a complement to tgeneric tests.

- add a new exception "division by zero" (IEEE-754 terminology) / "infinitary"
  (LIA-2 terminology). In IEEE 754R (2006 February 14 8:00):
    "The division by zero exception shall be signaled iff an exact
    infinite result is defined for an operation on finite operands.
    [such as a pole or logarithmic singularity.] In particular, the
    division by zero exception shall be signaled if the divisor is
    zero and the dividend is a finite nonzero number."

- in div.c, try to find a case for which cy != 0 after the line
        cy = mpn_sub_1 (sp + k, sp + k, qsize, cy);
  (which should be added to the tests), e.g. by having {vp, k} = 0, or
  prove that this cannot happen.

- add a configure test for --enable-logging to ignore the option if
  it cannot be supported. Modify the "configure --help" description
  to say "on systems that support it".

- allow generic tests to run with a restricted exponent range.

- add generic bad cases for functions that don't have an inverse
  function that is implemented (use a single Newton iteration).

- add bad cases for the internal error bound (by using a dichotomy
  between a bad case for the correct rounding and some input value
  with fewer Ziv iterations?).

- add an option to use a 32-bit exponent type (int) on LP64 machines,
  mainly for developers, in order to be able to test the case where the
  extended exponent range is the same as the default exponent range, on
  such platforms.

- test underflow/overflow detection of various functions (in particular
  mpfr_exp) in reduced exponent ranges, including ranges that do not
  contain 0.


##############################################################################
7. Portability
##############################################################################

- support the decimal64 function without requiring --with-gmp-build

- [Kevin about texp.c long strings]
  For strings longer than c99 guarantees, it might be cleaner to
  introduce a "tests_strdupcat" or something to concatenate literal
  strings into newly allocated memory.  I thought I'd done that in a
  couple of places already.  Arrays of chars are not much fun.

- use http://gcc.gnu.org/viewcvs/trunk/config/stdint.m4 for mpfr-gmp.h

- rename configure.in to configure.ac
                                                                                                                                                                                                        <?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!--
Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
Contributed by the Arenaire and Cacao projects, INRIA.

This file is part of the GNU MPFR Library.

The GNU MPFR Library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

The GNU MPFR Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the GNU MPFR Library; see the file COPYING.LESSER.  If not, see
http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
-->

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Frequently Asked Questions about MPFR</title>
<style type="text/css">/*<![CDATA[*/
/* Global stylesheet for visual media */

html, body
{
  background: white;
  color: black;
}

div.logo { float: right }
div.logo img { border: 0 }

div.footer img { border: 0 }

dt
{
  margin-top: 2ex;
  margin-bottom: 1ex;
  font-weight: bolder;
}

/* For testing: dd { background: #ddddff } */

table { margin: 0.5ex auto }

li { margin-top: 0.5ex; margin-bottom: 0.5ex }

dd + dd
{
  margin-top: 0;
  margin-bottom: 0;
  padding-top: 0.5ex;
  padding-bottom: 0;
}

li > p, dd > p
{
  margin-top: 0;
  margin-bottom: 0;
  padding-top: 0.5ex;
  padding-bottom: 0.5ex;
}

.block-code code, code.block-code,
.block-code samp, samp.block-code
{
  display: block;
  padding: 0.5ex 0;
  margin-left: 2em;
}

.nowrap { white-space: nowrap }

/*
dl.faq { counter-reset: faq }

dl.faq dt:before
{
  counter-increment: faq;
  content: counter(faq) ". ";
}
*/

dl.faq dt { background: #dddddd }

dl.faq dd
{
  border-left: 4px solid;
  border-color: transparent;
  margin-left: 0em;
  padding-left: 1.5em;
}

dl.faq dt:target + dd
{
  border-left-color: #aaaaaa;
}

var.env { font-style: normal }
/*]]>*/</style>
</head>

<body>

<h1>Frequently Asked Questions about <cite><acronym>MPFR</acronym></cite></h1>

<p><strong>Important notice: Problems with a particular version of
<cite><acronym>MPFR</acronym></cite> are discussed in the corresponding
bugs page.</strong></p>

<p>The latest version of this <acronym>FAQ</acronym> is available at
<a href="http://www.mpfr.org/faq.html">http://www.mpfr.org/faq.html</a>.
Please look at this version if possible.</p>

<ol>
<li><a href="#mpfr_vs_mpf">What are the differences between
<cite><acronym>MPF</acronym></cite> from <cite><acronym>GMP</acronym></cite>
and <cite><acronym>MPFR</acronym></cite>?</a></li>
<li><a href="#mpf2mpfr">How to convert my program written using
<cite><acronym>MPF</acronym></cite> to
<cite><acronym>MPFR</acronym></cite>?</a></li>
<li><a href="#no_libgmp">At configure time, I get the error: <q>libgmp not found or uses a different ABI.</q></a></li>
<li><a href="#undef_ref1">I get undefined reference to <code>__gmp_get_memory_functions</code>.</a></li>
<li><a href="#undef_ref2">When I link my program with
<cite><acronym>MPFR</acronym></cite>, I get undefined reference
to <code>__gmpXXXX</code>.</a></li>
<li><a href="#crash_high_prec">My program crashes with high precisions.</a></li>
<li><a href="#accuracy">Though I have increased the precision, the results
are not more accurate.</a></li>
<li><a href="#detect_mpfr">How can I detect <cite><acronym>MPFR</acronym></cite>
installation using <cite>autoconf</cite> or <cite>pkg-config</cite>?</a></li>
<li><a href="#cite">How to cite <cite><acronym>MPFR</acronym></cite> in a
scientific publication?</a></li>
</ol>

<dl class="faq">

<dt id="mpfr_vs_mpf">1. What are the differences between
<cite><acronym>MPF</acronym></cite> from <cite><acronym>GMP</acronym></cite>
and <cite><acronym>MPFR</acronym></cite>?</dt>

<dd><p>The main differences are:</p>
<ul>
<li><p>The precision of a <cite><acronym>MPFR</acronym></cite> variable
is the <em>exact</em> number of bits used for its mantissa, whereas in
<cite><acronym>MPF</acronym></cite>, the precision requested by the user
is a minimum value (<cite><acronym>MPF</acronym></cite> generally uses a
higher precision). With the additional difference below, this implies that
the <cite><acronym>MPFR</acronym></cite> results do not depend on the
number of bits (16, 32, 64 or more) of the underlying architecture.</p></li>
<li><p>As a consequence, <cite><acronym>MPFR</acronym></cite> uses a
base-2 exponent, whereas in <cite><acronym>MPF</acronym></cite>, this
is a base-2<sup>32</sup> or base-2<sup>64</sup> exponent, depending on
the limb size. For this reason (and other internal ones), the maximum
exponent range in <cite><acronym>MPFR</acronym></cite> is different
(and smaller, if the exponent is represented by the same type as in
<cite><acronym>MPF</acronym></cite>).</p></li>
<li><p><cite><acronym>MPFR</acronym></cite> provides an additional rounding
mode argument to its functions; furthermore, it is guaranteed that the
result of any operation is the nearest possible floating-point value from
the exact result (considering the input variables as exact values), taking
into account the precision of the destination variable and the rounding
mode. <cite><acronym>MPFR</acronym></cite> also says whether the rounded
result is above or below the exact result.</p></li>
<li><p><cite><acronym>MPFR</acronym></cite> supports much more functions
(in particular transcendental functions such as exponentials, logarithms,
trigonometric functions and so on) and special values: signed zeros,
infinities, not-a-number (NaN).</p></li>
</ul></dd>

<dt id="mpf2mpfr">2. How to convert my program written using
<cite><acronym>MPF</acronym></cite> to
<cite><acronym>MPFR</acronym></cite>?</dt>

<dd><p>You need to add <q><code>r</code></q> to the function names, and to
specify the rounding mode (<code>MPFR_RNDN</code> for rounding to nearest,
<code>MPFR_RNDZ</code> for rounding towards zero, <code>MPFR_RNDU</code>
for rounding towards plus infinity, <code>MPFR_RNDD</code> for rounding
towards minus infinity). You can also define macros as follows:
<code class="block-code">#define mpf_add(a, b, c) mpfr_add(a, b, c, MPFR_RNDN)</code></p>
<p>The header file <samp>mpf2mpfr.h</samp> from the
<cite><acronym>MPFR</acronym></cite> distribution automatically
redefines all <cite><acronym>MPF</acronym></cite> functions in this
way, using the default <cite><acronym>MPFR</acronym></cite> rounding
mode. Thus you simply need to add the following line in all your files
using <cite><acronym>MPF</acronym></cite> functions:
<code class="block-code">#include &lt;mpf2mpfr.h&gt;</code>
just after the <samp>gmp.h</samp> and <samp>mpfr.h</samp>
header files. If the program uses <cite><acronym>MPF</acronym></cite>
internals (such as direct access to <code>__mpf_struct</code> members),
additional changes will be needed.</p></dd>

<dt id="no_libgmp">3. At configure time, I get the error: <q>libgmp not found or uses a different ABI.</q></dt>

<dd><p>This test (<samp>checking for __gmpz_init in -lgmp</samp>) comes
after the <samp>gmp.h</samp> detection. The failure occurs either because
the <cite><acronym>GMP</acronym></cite> library could not be found
(as it is not in the provided library search paths) or because the
<cite><acronym>GMP</acronym></cite> library that was found does not have
the expected <acronym title="Application Binary Interface">ABI</acronym>
(<abbr>e.g.</abbr> 32-bit <abbr>vs</abbr> 64-bit). The latter problem can
have several causes:</p>
<ul>
<li>A wrong libgmp library has been picked up. This can occur if you have
several <cite><acronym>GMP</acronym></cite> versions installed on the
machine and something is wrong with the provided library search paths.</li>
<li>Wrong compiler options (<samp>CFLAGS</samp>) were given. In general, the
presence or absence of the <samp>-m64</samp> compiler option must match the
library <acronym title="Application Binary Interface">ABI</acronym>.</li>
<li>A wrong <samp>gmp.h</samp> file has been picked up (if you have several
<cite><acronym>GMP</acronym></cite> versions installed). Indeed, by default,
<cite><acronym>MPFR</acronym></cite> gets the compiler options from the
<samp>gmp.h</samp> file (with <cite><acronym>GMP</acronym></cite> 4.2.3
or later); this is needed because <cite><acronym>GMP</acronym></cite> does
not necessarily use the default <acronym>ABI</acronym>. The consequence is
that if the <samp>gmp.h</samp> file is associated with a library using a
different <acronym>ABI</acronym>, the <acronym>ABI</acronym>-related options
will be incorrect. Hence the failure.</li>
</ul>
<p>Note: The <samp>config.log</samp> output gives more information
than the error message. In particular, see the output of the test:
<samp>checking for CC and CFLAGS in gmp.h</samp>; it should give you
the default compiler options (from <samp>gmp.h</samp>).</p>

<p>See also the answer to the <a href="#undef_ref1">next question</a>.</p></dd>

<dt id="undef_ref1">4. I get undefined reference to <code>__gmp_get_memory_functions</code>.</dt>

<dd><p>Note: this was mainly a problem when upgrading from
<cite><acronym>GMP</acronym></cite> 4.1.4 to a later version,
but information given below may still be useful in other cases,
when several <cite><acronym>GMP</acronym></cite> libraries are
installed on the same machine.</p>

<p>If you get such an error, in particular when running
<samp>make check</samp>, then this probably means that you are using
the header file from <cite><acronym>GMP</acronym></cite> 4.2.x but the
<cite><acronym>GMP</acronym></cite> 4.1.4 library. This can happen if
several <cite><acronym>GMP</acronym></cite> versions are installed on
your machine (<abbr>e.g.</abbr>, one provided by the system in
<samp>/usr/{include,lib}</samp> and a new one installed by the owner or
administrator of the machine in <samp>/usr/local/{include,lib}</samp>)
and your include and library search paths are inconsistent. On various
<acronym>GNU</acronym>/Linux machines, this is unfortunately the case
by default (<samp>/usr/local/include</samp> is in the default include
search path, but <samp>/usr/local/lib</samp> is <em>not</em> in the
default library search path). Typical errors are:
<samp class="block-code">undefined reference to `__gmp_get_memory_functions'</samp>
in <samp>make check</samp>. The best solution is to add
<samp>/usr/local/include</samp> to your <var class="env">C_INCLUDE_PATH</var>
environment variable and to add <samp>/usr/local/lib</samp> to your
<var class="env">LIBRARY_PATH</var> and <var class="env">LD_LIBRARY_PATH</var>
environment variables (and/or <var class="env">LD_RUN_PATH</var>).
Alternatively, you can use <samp>--with-gmp*</samp> configure options,
<abbr>e.g.</abbr> <samp>--with-gmp=/usr/local</samp>, but <strong>this is
not guaranteed to work</strong> (in particular with <samp>gcc</samp> and
system directories such as <samp>/usr</samp> or <samp>/usr/local</samp>),
and other software that uses <cite><acronym>GMP</acronym></cite> and/or
<cite><acronym>MPFR</acronym></cite> will need correct paths too;
environment variables allow you to set them in a global way.</p>
<p>Other information can be given in the <samp>INSTALL</samp> file and
<samp>ld</samp> manual. Please look at them for more details. See also
the <a href="#undef_ref2">next question</a>.</p></dd>

<dt id="undef_ref2">5. When I link my program with
<cite><acronym>MPFR</acronym></cite>, I get undefined reference
to <code>__gmpXXXX</code>.</dt>

<dd><p>Link your program with <cite><acronym>GMP</acronym></cite>. Assuming
that your program is <samp>foo.c</samp>, you should link it using:
<samp class="block-code">cc link.c -lmpfr -lgmp</samp>
<cite><acronym>MPFR</acronym></cite> library reference (<samp>-lmpfr</samp>)
should be before <sÔ  tÔ  uÔ  vÔ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  cite><acronym>GMP</acronym></cite>'s one
(<samp>-lgmp</samp>). Another solution is, with <acronym>GNU</acronym>
<samp>ld</samp>, to give all the libraries inside a group:
<samp class="block-code">gcc link.c -Wl,--start-group libgmp.a libmpfr.a -Wl,--end-group</samp>
See <samp>INSTALL</samp> file and <samp>ld</samp> manual for more
details.</p>
<p>If you used correct link options, but still get an error, this may mean
that your include and library search paths are inconsistent. Please see the
<a href="#undef_ref1">previous question</a>.</p></dd>

<dt id="crash_high_prec">6. My program crashes with high precisions.</dt>

<dd><p>Your stack size limit may be too small; indeed, by default,
<cite><acronym>GMP</acronym></cite> 4.1.4 and below allocates all
temporary results on the stack, and in very high precisions, this
limit may be reached. You can solve this problem in different ways:</p>
<ul>
<li><p>You can upgrade to <cite><acronym>GMP</acronym></cite> 4.2 (or above),
which now makes temporary allocations on the stack only when they are
small.</p></li>
<li><p>You can increase the stack size limit with the <samp>limit</samp>,
<samp>unlimit</samp> or <samp>ulimit</samp> command, depending on your
shell. This may fail on some systems, where the maximum stack size cannot
be increased above some value.</p></li>
<li><p>You can rebuild both <cite><acronym>GMP</acronym></cite> and
<cite><acronym>MPFR</acronym></cite> to use another allocation method.</p></li>
</ul></dd>

<dt id="accuracy">7. Though I have increased the precision, the results
are not more accurate.</dt>

<dd><p>The reason may be the use of C floating-point numbers. If you want
to store a floating-point constant to a <code>mpfr_t</code>, you should use
<code>mpfr_set_str</code> (or one of the <cite><acronym>MPFR</acronym></cite>
constant functions, such as <code>mpfr_const_pi</code> for &#960;) instead
of <code>mpfr_set_d</code> or <code>mpfr_set_ld</code>. Otherwise the
floating-point constant will be first converted into a reduced-precision
(<abbr>e.g.</abbr>, 53-bit) binary number before
<cite><acronym>MPFR</acronym></cite> can work with it. This is the case
in particular for most exact decimal numbers, such as 0.17, which are
not exactly representable in binary.</p>
<p>Also remember that <cite><acronym>MPFR</acronym></cite> does not track
the accuracy of the results: copying a value <var>x</var> to <var>y</var>
with <code>mpfr_set (y, x, MPFR_RNDN)</code> where the variable <var>y</var>
is more precise than the variable <var>x</var> will not make it more
accurate; the (binary) value will remain unchanged.</p></dd>

<dt id="detect_mpfr">8. How can I detect <cite><acronym>MPFR</acronym></cite>
installation using <cite>autoconf</cite> or <cite>pkg-config</cite>?</dt>

<dd><p>The <cite><acronym>MPFR</acronym></cite> team does not currently
recommend any <cite>autoconf</cite> code, but a section will later
be added to the <cite><acronym>MPFR</acronym></cite> manual. The
<cite><acronym>MPFR</acronym></cite> team does not wish to support
<cite>pkg-config</cite> yet.</p></dd>

<dt id="cite">9. How to cite <cite><acronym>MPFR</acronym></cite> in a
scientific publication?</dt>

<dd><p>To properly cite <cite><acronym>MPFR</acronym></cite> in a scientific
publication, please cite the
<a href="http://doi.acm.org/10.1145/1236463.1236468"><acronym title="Association for Computing Machinery">ACM</acronym>
<acronym title="Transactions on Mathematical Software">TOMS</acronym>
paper</a>
(<a href="http://toms.acm.org/cgi/TOMSbibget.cgi?Fousse:2007:MMP">BibTeX</a>)
and/or the library web page
<a href="http://www.mpfr.org/">http://www.mpfr.org</a>. If your publication
is related to a particular release of <cite><acronym>MPFR</acronym></cite>,
for example if you report timings, please also indicate the release number
for future reference.</p></dd>

</dl>

</body>

</html>
                                                                                                                                                                                                                        Ð*   .   A   ..  Ñ*  èman1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Ñ*   .   Ð*   ..  Ò*   	windres.1   Ó*   	dlltool.1   Ô*   	c++filt.1   Õ*   nm.1Ö*   ranlib.1×*   	objdump.1   Ø*   ld.1Ù*   ar.1Ú*   gprof.1 Û*   windmc.1Ü*   	readelf.1   Ý*   strip.1 Þ*   	nlmconv.1   ß*   	strings.1   à*   as.1á*   	objcopy.1   â*   	elfedit.1   ã*   addr2line.1 ä*  °size.1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WINDRES 1"
.TH WINDRES 1 "2010-12-08" "binutils-2.21" "GNU Development Tools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
windres \- manipulate Windows resources.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
windres [options] [input\-file] [output\-file]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBwindres\fR reads resources from an input file and copies them into
an output file.  Either file may be in one of three formats:
.ie n .IP """rc""" 4
.el .IP "\f(CWrc\fR" 4
.IX Item "rc"
A text format read by the Resource Compiler.
.ie n .IP """res""" 4
.el .IP "\f(CWres\fR" 4
.IX Item "res"
A binary format generated by the Resource Compiler.
.ie n .IP """coff""" 4
.el .IP "\f(CWcoff\fR" 4
.IX Item "coff"
A \s-1COFF\s0 object or executable.
.PP
The exact description of these different formats is available in
documentation from Microsoft.
.PP
When \fBwindres\fR converts from the \f(CW\*(C`rc\*(C'\fR format to the \f(CW\*(C`res\*(C'\fR
format, it is acting like the Windows Resource Compiler.  When
\&\fBwindres\fR converts from the \f(CW\*(C`res\*(C'\fR format to the \f(CW\*(C`coff\*(C'\fR
format, it is acting like the Windows \f(CW\*(C`CVTRES\*(C'\fR program.
.PP
When \fBwindres\fR generates an \f(CW\*(C`rc\*(C'\fR file, the output is similar
but not identical to the format expected for the input.  When an input
\&\f(CW\*(C`rc\*(C'\fR file refers to an external filename, an output \f(CW\*(C`rc\*(C'\fR file
will instead include the file contents.
.PP
If the input or output format is not specified, \fBwindres\fR will
guess based on the file name, or, for the input file, the file contents.
A file with an extension of \fI.rc\fR will be treated as an \f(CW\*(C`rc\*(C'\fR
file, a file with an extension of \fI.res\fR will be treated as a
\&\f(CW\*(C`res\*(C'\fR file, and a file with an extension of \fI.o\fR or
\&\fI.exe\fR will be treated as a \f(CW\*(C`coff\*(C'\fR file.
.PP
If no output file is specified, \fBwindres\fR will print the resources
in \f(CW\*(C`rc\*(C'\fR format to standard output.
.PP
The normal use is for you to write an \f(CW\*(C`rc\*(C'\fR file, use \fBwindres\fR
to convert it to a \s-1COFF\s0 object file, and then link the \s-1COFF\s0 file into
your application.  This will make the resources described in the
\&\f(CW\*(C`rc\*(C'\fR file available to Windows.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-i\fR \fIfilename\fR" 4
.IX Item "-i filename"
.PD 0
.IP "\fB\-\-input\fR \fIfilename\fR" 4
.IX Item "--input filename"
.PD
The name of the input file.  If this option is not used, then
\&\fBwindres\fR will use the first non-option argument as the input file
name.  If there are no non-option arguments, then \fBwindres\fR will
read from standard input.  \fBwindres\fR can not read a \s-1COFF\s0 file from
standard input.
.IP "\fB\-o\fR \fIfilename\fR" 4
.IX Item "-o filename"
.PD 0
.IP "\fB\-\-output\fR \fIfilename\fR" 4
.IX Item "--output filename"
.PD
The name of the output file.  If this option is not used, then
\&\fBwindres\fR will use the first non-option argument, after any used
for the input file name, as the output file name.  If there is no
non-option argument, then \fBwindres\fR will write to standard output.
\&\fBwindres\fR can not write a \s-1COFF\s0 file to standard output.  Note,
for compatibility with \fBrc\fR the option \fB\-fo\fR is also
accepted, but its use is not recommended.
.IP "\fB\-J\fR \fIformat\fR" 4
.IX Item "-J format"
.PD 0
.IP "\fB\-\-input\-form